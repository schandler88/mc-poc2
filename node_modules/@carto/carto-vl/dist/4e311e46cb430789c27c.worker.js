/*!
 * CARTO VL js https://carto.com/
 * Version: 0.8.0
 * 
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/sources/MVTWorkers.worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@mapbox/point-geometry/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@mapbox/point-geometry/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Point;

/**
 * A standalone point geometry with useful accessor, comparison, and
 * modification methods.
 *
 * @class Point
 * @param {Number} x the x-coordinate. this could be longitude or screen
 * pixels, or any other sort of unit.
 * @param {Number} y the y-coordinate. this could be latitude or screen
 * pixels, or any other sort of unit.
 * @example
 * var point = new Point(-77, 38);
 */
function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {

    /**
     * Clone this point, returning a new point that can be modified
     * without affecting the old one.
     * @return {Point} the clone
     */
    clone: function() { return new Point(this.x, this.y); },

    /**
     * Add this point's x & y coordinates to another point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    add:     function(p) { return this.clone()._add(p); },

    /**
     * Subtract this point's x & y coordinates to from point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    sub:     function(p) { return this.clone()._sub(p); },

    /**
     * Multiply this point's x & y coordinates by point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    multByPoint:    function(p) { return this.clone()._multByPoint(p); },

    /**
     * Divide this point's x & y coordinates by point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    divByPoint:     function(p) { return this.clone()._divByPoint(p); },

    /**
     * Multiply this point's x & y coordinates by a factor,
     * yielding a new point.
     * @param {Point} k factor
     * @return {Point} output point
     */
    mult:    function(k) { return this.clone()._mult(k); },

    /**
     * Divide this point's x & y coordinates by a factor,
     * yielding a new point.
     * @param {Point} k factor
     * @return {Point} output point
     */
    div:     function(k) { return this.clone()._div(k); },

    /**
     * Rotate this point around the 0, 0 origin by an angle a,
     * given in radians
     * @param {Number} a angle to rotate around, in radians
     * @return {Point} output point
     */
    rotate:  function(a) { return this.clone()._rotate(a); },

    /**
     * Rotate this point around p point by an angle a,
     * given in radians
     * @param {Number} a angle to rotate around, in radians
     * @param {Point} p Point to rotate around
     * @return {Point} output point
     */
    rotateAround:  function(a,p) { return this.clone()._rotateAround(a,p); },

    /**
     * Multiply this point by a 4x1 transformation matrix
     * @param {Array<Number>} m transformation matrix
     * @return {Point} output point
     */
    matMult: function(m) { return this.clone()._matMult(m); },

    /**
     * Calculate this point but as a unit vector from 0, 0, meaning
     * that the distance from the resulting point to the 0, 0
     * coordinate will be equal to 1 and the angle from the resulting
     * point to the 0, 0 coordinate will be the same as before.
     * @return {Point} unit vector point
     */
    unit:    function() { return this.clone()._unit(); },

    /**
     * Compute a perpendicular point, where the new y coordinate
     * is the old x coordinate and the new x coordinate is the old y
     * coordinate multiplied by -1
     * @return {Point} perpendicular point
     */
    perp:    function() { return this.clone()._perp(); },

    /**
     * Return a version of this point with the x & y coordinates
     * rounded to integers.
     * @return {Point} rounded point
     */
    round:   function() { return this.clone()._round(); },

    /**
     * Return the magitude of this point: this is the Euclidean
     * distance from the 0, 0 coordinate to this point's x and y
     * coordinates.
     * @return {Number} magnitude
     */
    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    /**
     * Judge whether this point is equal to another point, returning
     * true or false.
     * @param {Point} other the other point
     * @return {boolean} whether the points are equal
     */
    equals: function(other) {
        return this.x === other.x &&
               this.y === other.y;
    },

    /**
     * Calculate the distance from this point to another point
     * @param {Point} p the other point
     * @return {Number} distance
     */
    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    /**
     * Calculate the distance from this point to another point,
     * without the square root step. Useful if you're comparing
     * relative distances.
     * @param {Point} p the other point
     * @return {Number} distance
     */
    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    /**
     * Get the angle from the 0, 0 coordinate to this point, in radians
     * coordinates.
     * @return {Number} angle
     */
    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    /**
     * Get the angle from this point to another point, in radians
     * @param {Point} b the other point
     * @return {Number} angle
     */
    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    /**
     * Get the angle between this point and another point, in radians
     * @param {Point} b the other point
     * @return {Number} angle
     */
    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    /*
     * Find the angle of the two vectors, solving the formula for
     * the cross product a x b = |a||b|sin(θ) for θ.
     * @param {Number} x the x-coordinate
     * @param {Number} y the y-coordinate
     * @return {Number} the angle in radians
     */
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _multByPoint: function(p) {
        this.x *= p.x;
        this.y *= p.y;
        return this;
    },

    _divByPoint: function(p) {
        this.x /= p.x;
        this.y /= p.y;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _rotateAround: function(angle, p) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),
            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

/**
 * Construct a point from an array if necessary, otherwise if the input
 * is already a Point, or an unknown type, return it unchanged
 * @param {Array<Number>|Point|*} a any kind of input value
 * @return {Point} constructed point, or passed-through value.
 * @example
 * // this
 * var point = Point.convert([0, 1]);
 * // is equivalent to
 * var point = new Point(0, 1);
 */
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};


/***/ }),

/***/ "./node_modules/@mapbox/vector-tile/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@mapbox/vector-tile/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports.VectorTile = __webpack_require__(/*! ./lib/vectortile.js */ "./node_modules/@mapbox/vector-tile/lib/vectortile.js");
module.exports.VectorTileFeature = __webpack_require__(/*! ./lib/vectortilefeature.js */ "./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js");
module.exports.VectorTileLayer = __webpack_require__(/*! ./lib/vectortilelayer.js */ "./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js");


/***/ }),

/***/ "./node_modules/@mapbox/vector-tile/lib/vectortile.js":
/*!************************************************************!*\
  !*** ./node_modules/@mapbox/vector-tile/lib/vectortile.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var VectorTileLayer = __webpack_require__(/*! ./vectortilelayer */ "./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js");

module.exports = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) layers[layer.name] = layer;
    }
}



/***/ }),

/***/ "./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Point = __webpack_require__(/*! @mapbox/point-geometry */ "./node_modules/@mapbox/point-geometry/index.js");

module.exports = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) feature.id = pbf.readVarint();
    else if (tag == 2) readTag(pbf, feature);
    else if (tag == 3) feature.type = pbf.readVarint();
    else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (length <= 0) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) lines.push(line);
                line = [];
            }

            line.push(new Point(x, y));

        } else if (cmd === 7) {

            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
            if (line) {
                line.push(line[0].clone()); // closePolygon
            }

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (length <= 0) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature.types[this.type],
        i, j;

    function project(line) {
        for (var j = 0; j < line.length; j++) {
            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }

    switch (this.type) {
    case 1:
        var points = [];
        for (i = 0; i < coords.length; i++) {
            points[i] = coords[i][0];
        }
        coords = points;
        project(coords);
        break;

    case 2:
        for (i = 0; i < coords.length; i++) {
            project(coords[i]);
        }
        break;

    case 3:
        coords = classifyRings(coords);
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                project(coords[i][j]);
            }
        }
        break;
    }

    if (coords.length === 1) {
        coords = coords[0];
    } else {
        type = 'Multi' + type;
    }

    var result = {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };

    if ('id' in this) {
        result.id = this.id;
    }

    return result;
};

// classifies an array of rings into polygons with outer rings and holes

function classifyRings(rings) {
    var len = rings.length;

    if (len <= 1) return [rings];

    var polygons = [],
        polygon,
        ccw;

    for (var i = 0; i < len; i++) {
        var area = signedArea(rings[i]);
        if (area === 0) continue;

        if (ccw === undefined) ccw = area < 0;

        if (ccw === area < 0) {
            if (polygon) polygons.push(polygon);
            polygon = [rings[i]];

        } else {
            polygon.push(rings[i]);
        }
    }
    if (polygon) polygons.push(polygon);

    return polygons;
}

function signedArea(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2.x - p1.x) * (p1.y + p2.y);
    }
    return sum;
}


/***/ }),

/***/ "./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var VectorTileFeature = __webpack_require__(/*! ./vectortilefeature.js */ "./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js");

module.exports = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 5) layer.extent = pbf.readVarint();
    else if (tag === 2) layer._features.push(pbf.pos);
    else if (tag === 3) layer._keys.push(pbf.readString());
    else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 ? pbf.readVarint64() :
            tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};


/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/pbf/index.js":
/*!***********************************!*\
  !*** ./node_modules/pbf/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Pbf;

var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");

function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            this.type = val & 0x7;
            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },

    readVarint: function(isSigned) {
        var buf = this.buf,
            val, b;

        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;
        b = buf[this.pos];   val |= (b & 0x0f) << 28;

        return readVarintRemainder(val, isSigned, this);
    },

    readVarint64: function() { // for compatibility with v2.0.1
        return this.readVarint(true);
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = readUtf8(this.buf, this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function(arr, isSigned) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readVarint(isSigned));
        return arr;
    },
    readPackedSVarint: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val || 0;

        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);

        this.pos++; // reserve 1 byte for short string length

        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(l, s, p) {
    var buf = p.buf,
        h, b;

    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);

    throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ?
        pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }

    return ((high >>> 0) * 0x100000000) + (low >>> 0);
}

function writeBigVarint(val, pbf) {
    var low, high;

    if (val >= 0) {
        low  = (val % 0x100000000) | 0;
        high = (val / 0x100000000) | 0;
    } else {
        low  = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);

        if (low ^ 0xffffffff) {
            low = (low + 1) | 0;
        } else {
            low = 0;
            high = (high + 1) | 0;
        }
    }

    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }

    pbf.realloc(10);

    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}

function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos]   = low & 0x7f;
}

function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 0x07) << 4;

    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f;
}

function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen =
        len <= 0x3fff ? 1 :
        len <= 0x1fffff ? 2 :
        len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
}

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

// Buffer code below from https://github.com/feross/buffer, MIT-licensed

function readUInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] * 0x1000000);
}

function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = (val >>> 8);
    buf[pos + 2] = (val >>> 16);
    buf[pos + 3] = (val >>> 24);
}

function readInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] << 24);
}

function readUtf8(buf, pos, end) {
    var str = '';
    var i = pos;

    while (i < end) {
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence =
            b0 > 0xEF ? 4 :
            b0 > 0xDF ? 3 :
            b0 > 0xBF ? 2 : 1;

        if (i + bytesPerSequence > end) break;

        var b1, b2, b3;

        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }

        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;

        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }

        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }

    return str;
}

function writeUtf8(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || (i + 1 === str.length)) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c;
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }

        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}


/***/ }),

/***/ "./src/client/WindshaftWorker.js":
/*!***************************************!*\
  !*** ./src/client/WindshaftWorker.js ***!
  \***************************************/
/*! exports provided: WindshaftWorker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WindshaftWorker", function() { return WindshaftWorker; });
/* harmony import */ var _sources_MVTWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sources/MVTWorker */ "./src/sources/MVTWorker.js");
/* harmony import */ var _renderer_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/schema */ "./src/renderer/schema.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var WindshaftWorker =
/*#__PURE__*/
function (_MVTWorker) {
  _inherits(WindshaftWorker, _MVTWorker);

  function WindshaftWorker() {
    _classCallCheck(this, WindshaftWorker);

    return _possibleConstructorReturn(this, _getPrototypeOf(WindshaftWorker).apply(this, arguments));
  }

  _createClass(WindshaftWorker, [{
    key: "decodeProperty",
    value: function decodeProperty(metadata, propertyName, propertyValue) {
      var basename = _renderer_schema__WEBPACK_IMPORTED_MODULE_1__["default"].column.getBase(propertyName);
      var column = metadata.properties[basename];

      if (!column) {
        return;
      }

      switch (column.type) {
        case 'date':
          return decodeDate(column, propertyValue);

        case 'category':
          return metadata.categorizeString(basename, propertyValue);

        case 'number':
          return propertyValue;

        default:
          throw new Error("Windshaft MVT decoding error. Feature property value of type '".concat(_typeof(propertyValue), "' cannot be decoded."));
      }
    }
  }]);

  return WindshaftWorker;
}(_sources_MVTWorker__WEBPACK_IMPORTED_MODULE_0__["MVTWorker"]);

function decodeDate(column, propertyValue) {
  var d = new Date();
  d.setTime(1000 * propertyValue);
  var min = column.min,
      max = column.max;
  var n = (d - min) / (max.getTime() - min.getTime());
  return n;
}

/***/ }),

/***/ "./src/client/mvt/feature-decoder.js":
/*!*******************************************!*\
  !*** ./src/client/mvt/feature-decoder.js ***!
  \*******************************************/
/*! exports provided: Polygon, decodeLines, decodePolygons, signedPolygonArea, clipPolygon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return Polygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeLines", function() { return decodeLines; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePolygons", function() { return decodePolygons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "signedPolygonArea", function() { return signedPolygonArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipPolygon", function() { return clipPolygon; });
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/geometry */ "./src/utils/geometry.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }


var Polygon = function Polygon() {
  _classCallCheck(this, Polygon);

  this.flat = [];
  this.holes = [];
  this.clipped = [];
  this.clippedType = []; // Store a bitmask of the clipped half-planes
};
function decodeLines(geometries, mvtExtent) {
  var decodedGeometries = [];
  geometries.map(function (l) {
    var line = [];
    l.map(function (point) {
      line.push([2 * point.x / mvtExtent - 1, 2 * (1 - point.y / mvtExtent) - 1]);
    });
    decodedGeometries.push.apply(decodedGeometries, _toConsumableArray(clipLine(line)));
  });
  return decodedGeometries;
}
/*
    All this clockwise non-sense is needed because the MVT decoder dont decode the MVT fully.
    It doesn't distinguish between internal polygon rings (which defines holes) or external ones, which defines more polygons (mulipolygons)
    See:
        https://github.com/mapbox/vector-tile-spec/tree/master/2.1
        https://en.wikipedia.org/wiki/Shoelace_formula
*/

function decodePolygons(geometries, mvtExtent) {
  var currentPolygon = null;
  var decoded = [];
  var invertedOrientation;
  geometries.forEach(function (geom) {
    var area = signedPolygonArea(geom);

    if (area === 0) {
      return;
    }

    if (invertedOrientation === undefined) {
      // According to the MVT spec this condition cannot happen for
      // MVT spec compliant tiles, but many buggy implementations
      // don't comply with this rule when generating tiles
      // Also, other implementations accept this out-of-the-spec condition
      invertedOrientation = area > 0;
    }

    var isExternalPolygon = invertedOrientation ? area > 0 : area < 0;

    var preClippedVertices = _getPreClippedVertices(geom, mvtExtent);

    if (isExternalPolygon) {
      if (currentPolygon) {
        decoded.push(currentPolygon);
      }

      currentPolygon = new Polygon();
    }

    currentPolygon = clipPolygon(preClippedVertices, currentPolygon, !isExternalPolygon);
  });

  if (currentPolygon) {
    decoded.push(currentPolygon);
  }

  return decoded;
}
function signedPolygonArea(vertices) {
  // https://en.wikipedia.org/wiki/Shoelace_formula
  var a = 0;

  for (var i = 0; i < vertices.length; i++) {
    var j = (i + 1) % vertices.length;
    a += vertices[i].x * vertices[j].y;
    a -= vertices[j].x * vertices[i].y;
  }

  return a / 2;
}
var CLIPMAX = 1;
var CLIPMIN = -CLIPMAX;
var clippingEdges = [{
  // Right edge; x <= CLIPMAX for points inside
  inside: function inside(p) {
    return p[0] <= CLIPMAX;
  },
  intersect: function intersect(a, b) {
    return _utils_geometry__WEBPACK_IMPORTED_MODULE_0__["default"].intersect(a, b, [CLIPMAX, -100], [CLIPMAX, 100]);
  }
}, {
  // Top edge; y <= CLIPMAX for points inside
  inside: function inside(p) {
    return p[1] <= CLIPMAX;
  },
  intersect: function intersect(a, b) {
    return _utils_geometry__WEBPACK_IMPORTED_MODULE_0__["default"].intersect(a, b, [-100, CLIPMAX], [100, CLIPMAX]);
  }
}, {
  // Left edge; x >= CLIPMIN for points inside
  inside: function inside(p) {
    return p[0] >= CLIPMIN;
  },
  intersect: function intersect(a, b) {
    return _utils_geometry__WEBPACK_IMPORTED_MODULE_0__["default"].intersect(a, b, [CLIPMIN, -100], [CLIPMIN, 100]);
  }
}, {
  // Bottom edge; y >= CLIPMIN for points inside
  inside: function inside(p) {
    return p[1] >= CLIPMIN;
  },
  intersect: function intersect(a, b) {
    return _utils_geometry__WEBPACK_IMPORTED_MODULE_0__["default"].intersect(a, b, [-100, CLIPMIN], [100, CLIPMIN]);
  }
}];
var numberOfEdges = clippingEdges.length;
function clipPolygon(preClippedVertices, polygon, isHole) {
  // Sutherland-Hodgman Algorithm to clip polygons to the tile
  // https://www.cs.drexel.edu/~david/Classes/CS430/Lectures/L-05_Polygons.6.pdf
  var clippedTypes = {}; // for each clipping edge

  var _loop = function _loop(i) {
    var preClippedVertices2 = [];
    var clippedTypes2 = {};

    var setClippedType = function setClippedType(vertexIndex, oldVertexIndex) {
      var edge = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      var clippedType = 0;

      if (oldVertexIndex >= 0) {
        clippedType = clippedTypes[oldVertexIndex] || 0;
      }

      if (edge >= 0) {
        clippedType = clippedType | 1 << edge;
      }

      if (clippedType) {
        clippedTypes2[vertexIndex] = clippedType;
      }
    }; // for each edge on polygon


    for (var k = 0; k < preClippedVertices.length - 1; k++) {
      // clip polygon edge
      var a = preClippedVertices[k];
      var b = preClippedVertices[k + 1];
      var insideA = clippingEdges[i].inside(a);
      var insideB = clippingEdges[i].inside(b);

      if (insideA && insideB) {
        // case 1: both inside, push B vertex
        setClippedType(preClippedVertices2.length, k + 1);
        preClippedVertices2.push(b);
      } else if (insideA) {
        // case 2: just B outside, push intersection
        var intersectionPoint = clippingEdges[i].intersect(a, b);
        setClippedType(preClippedVertices2.length, k + 1, i);
        preClippedVertices2.push(intersectionPoint);
      } else if (insideB) {
        // case 4: just A outside: push intersection, push B
        var _intersectionPoint = clippingEdges[i].intersect(a, b);

        setClippedType(preClippedVertices2.length, k, i);
        preClippedVertices2.push(_intersectionPoint);
        setClippedType(preClippedVertices2.length, k + 1);
        preClippedVertices2.push(b);
      } else {// case 3: both outside: do nothing
      }
    }

    if (preClippedVertices2.length) {
      if (clippedTypes2[0]) {
        clippedTypes2[preClippedVertices2.length] = clippedTypes2[0];
      }

      preClippedVertices2.push(preClippedVertices2[0]);
    }

    preClippedVertices = preClippedVertices2;
    clippedTypes = clippedTypes2;
  };

  for (var i = 0; i < numberOfEdges; i++) {
    _loop(i);
  } // rings with less than 3 vertices are degenerate


  var MIN_VALID_NUM_VERTICES = 3; // preClippedVertices is closed by repeating the first vertex

  if (preClippedVertices.length >= MIN_VALID_NUM_VERTICES + 1) {
    if (isHole) {
      polygon.holes.push(polygon.flat.length / 2);
    }

    preClippedVertices.forEach(function (v) {
      polygon.flat.push(v[0], v[1]);
    });
    Object.keys(clippedTypes).forEach(function (i) {
      polygon.clipped.push(Number(i) * 2);
      polygon.clippedType.push(clippedTypes[i]);
    });
  }

  return polygon;
}

function _getPreClippedVertices(geom, mvtExtent) {
  return geom.map(function (coord) {
    var x = coord.x;
    var y = coord.y;
    x = 2 * x / mvtExtent - 1;
    y = 2 * (1 - y / mvtExtent) - 1;
    return [x, y];
  });
}

function clipLine(line) {
  // linestring clipping based on the Cohen-Sutherland algorithm
  // input is a single linestring [point0, point1, ...]
  // output is an array of flat linestrings:
  // [[p0x, p0y, p1x, p1y, ...], ...]
  var clippedLine = [];
  var clippedLines = [];

  function clipType(point) {
    var type = 0;

    for (var i = 0; i < numberOfEdges; i++) {
      type = type | (clippingEdges[i].inside(point) ? 0 : 1 << i);
    }

    return type;
  }

  function intersect(point1, point2, type) {
    for (var i = 0; i < numberOfEdges; i++) {
      var mask = 1 << i;

      if (type & mask) {
        var p = clippingEdges[i].intersect(point1, point2);
        type = clipType(p) & ~mask;
        return [p, type];
      }
    }
  }

  var point0 = line[0];
  var type0 = clipType(point0);

  for (var i = 1; i < line.length; ++i) {
    var point1 = line[i];
    var type1 = clipType(point1);
    var nextType = type1;
    var nextPoint = point1;

    for (;;) {
      if (!(type0 | type1)) {
        var _clippedLine;

        // both points inside
        (_clippedLine = clippedLine).push.apply(_clippedLine, _toConsumableArray(point0));

        if (type1 !== nextType) {
          var _clippedLine2;

          (_clippedLine2 = clippedLine).push.apply(_clippedLine2, _toConsumableArray(point1));

          if (i < line.length - 1) {
            // break line
            clippedLines.push(clippedLine);
            clippedLine = [];
          }
        } else if (i === line.length - 1) {
          var _clippedLine3;

          (_clippedLine3 = clippedLine).push.apply(_clippedLine3, _toConsumableArray(point1));
        }

        break;
      } else if (type0 & type1) {
        // both points outside
        break;
      } else if (type0) {
        // only point1 inside
        var _intersect = intersect(point0, point1, type0);

        var _intersect2 = _slicedToArray(_intersect, 2);

        point0 = _intersect2[0];
        type0 = _intersect2[1];
      } else {
        // only point0 inside
        var _intersect3 = intersect(point0, point1, type1);

        var _intersect4 = _slicedToArray(_intersect3, 2);

        point1 = _intersect4[0];
        type1 = _intersect4[1];
      }
    }

    point0 = nextPoint;
    type0 = nextType;
  }

  clippedLine = _removeDuplicatedVerticesOnLine(clippedLine);

  if (clippedLine.length > 0) {
    clippedLines.push(clippedLine);
  }

  return clippedLines;
}

function _removeDuplicatedVerticesOnLine(line) {
  var result = [];
  var prevX;
  var prevY;

  for (var i = 0; i < line.length; i += 2) {
    var x = line[i];
    var y = line[i + 1];

    if (x !== prevX || y !== prevY) {
      result.push(x, y);
      prevX = x;
      prevY = y;
    }
  }

  return result;
}

/***/ }),

/***/ "./src/client/rsys.js":
/*!****************************!*\
  !*** ./src/client/rsys.js ***!
  \****************************/
/*! exports provided: wToR, rTiles, getRsysFromTile, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wToR", function() { return wToR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rTiles", function() { return rTiles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRsysFromTile", function() { return getRsysFromTile; });
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * An RSys defines a local coordinate system that maps the coordinates
 * in the range -1 <= x <= +1; -1 <= y <= +1 to an arbitrary rectangle
 * in an external coordinate system. (e.g. Dataframe coordinates to World coordinates)
 * It is the combination of a translation and anisotropic scaling.
 * @typedef {object} RSys - Renderer relative coordinate system
 * @property {RPoint} center - Position of the local system in external coordinates
 * @property {number} scale - Y-scale (local Y-distance / external Y-distance)
*/

/*
 * Random notes
 *
 * We can redefine Dataframe to use a Rsys instead of center, scale
 * and we can use an Rsys for the Renderer's canvas.
 *
 * Some interesting World coordinate systems:
 *
 * WM (Webmercator): represents a part of the world (excluding polar regions)
 * with coordinates in the range +/-WM_R for both X and Y. (positive orientation: E,N)
 *
 * NWMC (Normalized Webmercator Coordinates): represents the Webmercator *square*
 * with coordinates in the range +/-1. Results from dividing Webmercator coordinates
 * by WM_R. (positive orientation: E,N)
 *
 * TC (Tile coordinates): integers in [0, 2^Z) for zoom level Z. Example: the tile 0/0/0 (zoom, x, y) is the root tile.
 * (positive orientation: E,S)
 *
 * An RSys's rectangle (its bounds) is the area covered by the local coordinates in
 * the range +/-1.
 *
 * When an RSys external coordinate system is WM or NWMC, we can compute:
 * * Minimum zoom level for which tiles are no larger than the RSys rectangle:
 *   Math.ceil(Math.log2(1 / r.scale));
 * * Maximum zoom level for which tiles are no smaller than the rectangle:
 *   Math.floor(Math.log2(1 / r.scale));
 * (note that 1 / r.scale is the fraction of the World height that the local rectangle's height represents)
 *
 * We'll use the term World coordinates below for the *external* reference system
 * of an RSys (usually NWMC).
 */

/* eslint no-unused-vars: ["off"] */

/**
 * R coordinates to World
 * @param {RSys} r - ref. of the passed coordinates
 * @param {number} x - x coordinate in r
 * @param {number} y - y coordinate in r
 * @return {RPoint} World coordinates
 */
function rToW(r, x, y) {
  return {
    x: x * r.scale + r.center.x,
    y: y * r.scale + r.center.y
  };
}
/**
 * World coordinates to local RSys
 * @param {number} x - x W-coordinate
 * @param {number} y - y W-coordinate
 * @param {RSys} r - target ref. system
 * @return {RPoint} R coordinates
 */


function wToR(x, y, r) {
  return {
    x: (x - r.center.x) / r.scale,
    y: (y - r.center.y) / r.scale
  };
}
/**
 * RSys of a tile (mapping local tile coordinates in +/-1 to NWMC)
 * @param {number} x - TC x coordinate
 * @param {number} y - TC y coordinate
 * @param {number} z - Tile zoom level
 * @return {RSys}
 */

function tileRsys(x, y, z) {
  var max = Math.pow(2, z);
  return {
    scale: 1 / max,
    center: {
      x: 2 * (x + 0.5) / max - 1,
      y: 1 - 2 * (y + 0.5) / max
    }
  };
}
/**
 * TC tiles that intersect the local rectangle of an RSys
 * (with the largest tile size no larger than the rectangle)
 * @param {RSys} rsys
 * @return {Array} - array of TC tiles {x, y, z}
 */


function rTiles(zoom, bounds) {
  var viewportZoomToSourceZoom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Math.ceil;
  return wRectangleTiles(viewportZoomToSourceZoom(zoom), bounds);
}
/**
 * TC tiles of a given zoom level that intersect a W rectangle
 * @param {number} z
 * @param {Array} - rectangle extents [minx, miny, maxx, maxy]
 * @return {Array} - array of TC tiles {x, y, z}
 */

function wRectangleTiles(z, wr) {
  var _wr = _slicedToArray(wr, 4),
      wMinx = _wr[0],
      wMiny = _wr[1],
      wMaxx = _wr[2],
      wMaxy = _wr[3];

  var n = 1 << z; // for 0 <= z <= 30 equals Math.pow(2, z)

  var clamp = function clamp(x) {
    return Math.min(Math.max(x, 0), n - 1);
  }; // compute tile coordinate ranges


  var tMinx = clamp(Math.floor(n * (wMinx + 1) * 0.5));
  var tMaxx = clamp(Math.ceil(n * (wMaxx + 1) * 0.5) - 1);
  var tMiny = clamp(Math.floor(n * (1 - wMaxy) * 0.5));
  var tMaxy = clamp(Math.ceil(n * (1 - wMiny) * 0.5) - 1);
  var tiles = [];

  for (var x = tMinx; x <= tMaxx; ++x) {
    for (var y = tMiny; y <= tMaxy; ++y) {
      tiles.push({
        x: x,
        y: y,
        z: z
      });
    }
  }

  return tiles;
}
/**
 * Get the Rsys of a tile where the Rsys's center is the tile center and the Rsys's scale is the tile extent.
 * @param {*} x
 * @param {*} y
 * @param {*} z
 * @returns {RSys}
 */


function getRsysFromTile(x, y, z) {
  return {
    center: {
      x: (x + 0.5) / Math.pow(2, z) * 2.0 - 1,
      y: (1.0 - (y + 0.5) / Math.pow(2, z)) * 2.0 - 1.0
    },
    scale: 1 / Math.pow(2, z)
  };
}
/* harmony default export */ __webpack_exports__["default"] = ({
  rTiles: rTiles,
  getRsysFromTile: getRsysFromTile,
  wToR: wToR
});

/***/ }),

/***/ "./src/renderer/DummyDataframe.js":
/*!****************************************!*\
  !*** ./src/renderer/DummyDataframe.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DummyDataframe; });
/* harmony import */ var _decoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decoder */ "./src/renderer/decoder/index.js");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/geometry */ "./src/utils/geometry.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }




var DummyDataframe = function DummyDataframe(_ref) {
  var center = _ref.center,
      scale = _ref.scale,
      geom = _ref.geom,
      properties = _ref.properties,
      type = _ref.type,
      active = _ref.active,
      size = _ref.size,
      metadata = _ref.metadata;

  _classCallCheck(this, DummyDataframe);

  this.active = active;
  this.center = center;
  this.properties = properties;
  this.scale = scale;
  this.type = type;
  this.decodedGeom = Object(_decoder__WEBPACK_IMPORTED_MODULE_0__["decodeGeom"])(type, geom);
  this.numVertex = type === 'point' ? size * 3 : this.decodedGeom.vertices.length / 2;
  this.numFeatures = type === 'point' ? size : this.decodedGeom.breakpoints.length || this.numVertex;
  this.propertyTex = [];
  this.metadata = metadata;
  this.propertyCount = 0;
  this._aabb = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_1__["computeAABB"])(geom, type);
};



/***/ }),

/***/ "./src/renderer/Metadata.js":
/*!**********************************!*\
  !*** ./src/renderer/Metadata.js ***!
  \**********************************/
/*! exports provided: IDENTITY, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IDENTITY", function() { return IDENTITY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Metadata; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// The IDENTITY metadata contains zero properties
var IDENTITY = {
  properties: {}
};

var Metadata =
/*#__PURE__*/
function () {
  function Metadata() {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      properties: {}
    },
        properties = _ref.properties,
        featureCount = _ref.featureCount,
        sample = _ref.sample,
        geomType = _ref.geomType,
        isAggregated = _ref.isAggregated,
        idProperty = _ref.idProperty;

    _classCallCheck(this, Metadata);

    this.properties = properties;
    this.featureCount = featureCount;
    this.sample = sample;
    this.geomType = geomType;
    this.isAggregated = isAggregated;
    this.idProperty = idProperty || 'cartodb_id';
    this.categoryToID = new Map();
    this.IDToCategory = new Map();
    this.numCategories = 0;
    Object.values(properties).map(function (property) {
      property.categories = property.categories || [];
      property.categories.map(function (category) {
        return _this.categorizeString(property, category.name, true);
      });
    });
    this.propertyKeys = Object.keys(this.properties);
  }

  _createClass(Metadata, [{
    key: "categorizeString",
    value: function categorizeString(propertyName, category) {
      var init = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (category === undefined) {
        category = null;
      }

      if (this.categoryToID.has(category)) {
        return this.categoryToID.get(category);
      }

      if (!init) {
        this.properties[propertyName].categories.push({
          name: category,
          frequency: Number.NaN
        });
      }

      this.categoryToID.set(category, this.numCategories);
      this.IDToCategory.set(this.numCategories, category);
      this.numCategories++;
      return this.numCategories - 1;
    }
  }, {
    key: "propertyNames",
    value: function propertyNames(propertyName) {
      var prop = this.properties[propertyName];

      if (prop.aggregations) {
        return Object.keys(prop.aggregations).map(function (fn) {
          return prop.aggregations[fn];
        });
      }

      return [propertyName];
    }
  }]);

  return Metadata;
}();



/***/ }),

/***/ "./src/renderer/decoder/common.js":
/*!****************************************!*\
  !*** ./src/renderer/decoder/common.js ***!
  \****************************************/
/*! exports provided: addLineString, resizeBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLineString", function() { return addLineString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeBuffer", function() { return resizeBuffer; });
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/geometry */ "./src/utils/geometry.js");

/**
 * Create a triangulated lineString: zero-sized, vertex-shader expanded triangle list
 * with `miter` joins. For angle < 60 joins are automatically adjusted to `bevel`.
 * https://github.com/CartoDB/carto-vl/wiki/Line-rendering
 */

function addLineString(lineString, geomBuffer, index, isPolygon, skipCallback) {
  var prevPoint, currentPoint, nextPoint;
  var prevNormal, nextNormal;
  var drawLine; // We need at least two points

  if (lineString.length >= 4) {
    // Initialize the first two points
    prevPoint = [lineString[0], lineString[1]];
    currentPoint = [lineString[2], lineString[3]];
    prevNormal = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__["getLineNormal"])(prevPoint, currentPoint);

    for (var i = 4; i <= lineString.length; i += 2) {
      drawLine = !(skipCallback && skipCallback(i));

      if (drawLine) {
        // First triangle
        geomBuffer.vertices[index] = prevPoint[0];
        geomBuffer.normals[index++] = -prevNormal[0];
        geomBuffer.vertices[index] = prevPoint[1];
        geomBuffer.normals[index++] = -prevNormal[1];
        geomBuffer.vertices[index] = prevPoint[0];
        geomBuffer.normals[index++] = prevNormal[0];
        geomBuffer.vertices[index] = prevPoint[1];
        geomBuffer.normals[index++] = prevNormal[1];
        geomBuffer.vertices[index] = currentPoint[0];
        geomBuffer.normals[index++] = prevNormal[0];
        geomBuffer.vertices[index] = currentPoint[1];
        geomBuffer.normals[index++] = prevNormal[1]; // Second triangle

        geomBuffer.vertices[index] = prevPoint[0];
        geomBuffer.normals[index++] = -prevNormal[0];
        geomBuffer.vertices[index] = prevPoint[1];
        geomBuffer.normals[index++] = -prevNormal[1];
        geomBuffer.vertices[index] = currentPoint[0];
        geomBuffer.normals[index++] = prevNormal[0];
        geomBuffer.vertices[index] = currentPoint[1];
        geomBuffer.normals[index++] = prevNormal[1];
        geomBuffer.vertices[index] = currentPoint[0];
        geomBuffer.normals[index++] = -prevNormal[0];
        geomBuffer.vertices[index] = currentPoint[1];
        geomBuffer.normals[index++] = -prevNormal[1];
      } // If there is a next point, compute its properties


      if (i <= lineString.length - 2) {
        nextPoint = [lineString[i], lineString[i + 1]];
      } else if (isPolygon) {
        nextPoint = [lineString[2], lineString[3]];
      }

      if (nextPoint) {
        nextNormal = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__["getLineNormal"])(currentPoint, nextPoint);

        if (drawLine) {
          // `turnLeft` indicates that the nextLine turns to the left
          // `joinNormal` contains the direction and size for the `miter` vertex
          //  If this is not defined means that the join must be `bevel`.
          var _getJoinNormal = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__["getJoinNormal"])(prevNormal, nextNormal),
              turnLeft = _getJoinNormal.turnLeft,
              joinNormal = _getJoinNormal.joinNormal;

          var leftNormal = turnLeft ? prevNormal : Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__["neg"])(nextNormal);
          var rightNormal = turnLeft ? nextNormal : Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__["neg"])(prevNormal); // Third triangle

          geomBuffer.vertices[index] = currentPoint[0];
          geomBuffer.normals[index++] = 0;
          geomBuffer.vertices[index] = currentPoint[1]; // Mark vertex to be stroke in PolygonShader with the
          // non-zero value 1e-37, so it validates the expression
          // `normal != vec2(0.)` without affecting the vertex position.

          geomBuffer.normals[index++] = isPolygon ? 1e-37 : 0;
          geomBuffer.vertices[index] = currentPoint[0];
          geomBuffer.normals[index++] = leftNormal[0];
          geomBuffer.vertices[index] = currentPoint[1];
          geomBuffer.normals[index++] = leftNormal[1];
          geomBuffer.vertices[index] = currentPoint[0];
          geomBuffer.normals[index++] = rightNormal[0];
          geomBuffer.vertices[index] = currentPoint[1];
          geomBuffer.normals[index++] = rightNormal[1];

          if (joinNormal) {
            // Forth triangle
            geomBuffer.vertices[index] = currentPoint[0];
            geomBuffer.normals[index++] = joinNormal[0];
            geomBuffer.vertices[index] = currentPoint[1];
            geomBuffer.normals[index++] = joinNormal[1];
            geomBuffer.vertices[index] = currentPoint[0];
            geomBuffer.normals[index++] = rightNormal[0];
            geomBuffer.vertices[index] = currentPoint[1];
            geomBuffer.normals[index++] = rightNormal[1];
            geomBuffer.vertices[index] = currentPoint[0];
            geomBuffer.normals[index++] = leftNormal[0];
            geomBuffer.vertices[index] = currentPoint[1];
            geomBuffer.normals[index++] = leftNormal[1];
          }
        }
      } // Update the variables for the next iteration


      prevPoint = currentPoint;
      currentPoint = nextPoint;
      prevNormal = nextNormal;
      nextPoint = null;
    }
  }

  return index;
}
/**
 * Resize a Float32Array buffer in an efficient way
 */

function resizeBuffer(oldBuffer, newSize) {
  var newBuffer = new Float32Array(newSize);
  newBuffer.set(oldBuffer);
  return newBuffer;
}

/***/ }),

/***/ "./src/renderer/decoder/index.js":
/*!***************************************!*\
  !*** ./src/renderer/decoder/index.js ***!
  \***************************************/
/*! exports provided: decodeGeom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeGeom", function() { return decodeGeom; });
/* harmony import */ var _pointDecoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pointDecoder */ "./src/renderer/decoder/pointDecoder.js");
/* harmony import */ var _lineDecoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lineDecoder */ "./src/renderer/decoder/lineDecoder.js");
/* harmony import */ var _polygonDecoder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polygonDecoder */ "./src/renderer/decoder/polygonDecoder.js");



function decodeGeom(geomType, geom) {
  switch (geomType) {
    case 'point':
      return Object(_pointDecoder__WEBPACK_IMPORTED_MODULE_0__["decodePoint"])(geom);

    case 'line':
      return Object(_lineDecoder__WEBPACK_IMPORTED_MODULE_1__["decodeLine"])(geom);

    case 'polygon':
      return Object(_polygonDecoder__WEBPACK_IMPORTED_MODULE_2__["decodePolygon"])(geom);

    default:
      throw new Error("Unimplemented geometry type: '".concat(geomType, "'"));
  }
}

/***/ }),

/***/ "./src/renderer/decoder/lineDecoder.js":
/*!*********************************************!*\
  !*** ./src/renderer/decoder/lineDecoder.js ***!
  \*********************************************/
/*! exports provided: decodeLine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeLine", function() { return decodeLine; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/renderer/decoder/common.js");
 // If the geometry type is 'line' it will generate the appropriate zero-sized, vertex-shader expanded triangle list with `miter` and `bevel` joins.
// The geom will be an array of coordinates in this case

var STATIC_INITIAL_BUFFER_SIZE = 1024 * 1024; // 4 MB

var MAX_VERTICES_COORDINATES_PER_SEGMENT = 24;
var index = 0;
var geomBuffer = {
  vertices: new Float32Array(STATIC_INITIAL_BUFFER_SIZE),
  normals: new Float32Array(STATIC_INITIAL_BUFFER_SIZE)
};
function decodeLine(geometry) {
  var breakpoints = []; // Array of indices (to vertexArray) that separate each feature

  var featureIDToVertexIndex = new Map();
  index = 0;

  for (var i = 0; i < geometry.length; i++) {
    var feature = geometry[i];

    for (var j = 0; j < feature.length; j++) {
      // Increase buffers size if required
      resizeBuffers(MAX_VERTICES_COORDINATES_PER_SEGMENT * feature[j].length); // Add line string

      index = Object(_common__WEBPACK_IMPORTED_MODULE_0__["addLineString"])(feature[j], geomBuffer, index);
    }

    featureIDToVertexIndex.set(breakpoints.length, breakpoints.length === 0 ? {
      start: 0,
      end: index
    } : {
      start: featureIDToVertexIndex.get(breakpoints.length - 1).end,
      end: index
    });
    breakpoints.push(index);
  }

  var verticesArrayBuffer = new ArrayBuffer(4 * index);
  var normalsArrayBuffer = new ArrayBuffer(4 * index);
  var vertices = new Float32Array(verticesArrayBuffer);
  var normals = new Float32Array(normalsArrayBuffer);

  for (var _i = 0; _i < index; _i++) {
    vertices[_i] = geomBuffer.vertices[_i];
    normals[_i] = geomBuffer.normals[_i];
  }

  return {
    vertices: vertices,
    normals: normals,
    verticesArrayBuffer: verticesArrayBuffer,
    normalsArrayBuffer: normalsArrayBuffer,
    featureIDToVertexIndex: featureIDToVertexIndex,
    breakpoints: breakpoints
  };
} // Resize buffers as needed if `additionalSize` floats overflow the current buffers.

function resizeBuffers(additionalSize) {
  var minimumNeededSize = index + additionalSize;

  if (minimumNeededSize > geomBuffer.vertices.length) {
    var newSize = 2 * minimumNeededSize;
    geomBuffer.vertices = Object(_common__WEBPACK_IMPORTED_MODULE_0__["resizeBuffer"])(geomBuffer.vertices, newSize);
    geomBuffer.normals = Object(_common__WEBPACK_IMPORTED_MODULE_0__["resizeBuffer"])(geomBuffer.normals, newSize);
  }
}

/***/ }),

/***/ "./src/renderer/decoder/pointDecoder.js":
/*!**********************************************!*\
  !*** ./src/renderer/decoder/pointDecoder.js ***!
  \**********************************************/
/*! exports provided: decodePoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePoint", function() { return decodePoint; });
// If the geometry type is 'point' it will pass trough the geom (the vertex array)
function decodePoint(verticesArrayBuffer) {
  return {
    verticesArrayBuffer: verticesArrayBuffer,
    vertices: new Float32Array(verticesArrayBuffer),
    breakpoints: []
  };
}

/***/ }),

/***/ "./src/renderer/decoder/polygonDecoder.js":
/*!************************************************!*\
  !*** ./src/renderer/decoder/polygonDecoder.js ***!
  \************************************************/
/*! exports provided: decodePolygon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePolygon", function() { return decodePolygon; });
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! earcut */ "./node_modules/earcut/src/earcut.js");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(earcut__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ "./src/renderer/decoder/common.js");

 // If the geometry type is 'polygon' it will triangulate the polygon list (geom)
// geom will be a list of polygons in which each polygon will have a flat array of vertices and a list of holes indices
// Example:

/*   let geom = [{
       flat: [
         0.,0., 1.,0., 1.,1., 0.,1., 0.,0, //A square
         0.25,0.25, 0.75,0.25, 0.75,0.75, 0.25,0.75, 0.25,0.25//A small square
       ]
       holes: [5]
     }]
*/

var STATIC_INITIAL_BUFFER_SIZE = 1024 * 1024 * 2; // 8 MB

var VERTEX_COORDINATES_PER_TRIANGLE = 2;
var MAX_VERTICES_COORDINATES_PER_SEGMENT = 24;
var index = 0;
var geomBuffer = {
  vertices: new Float32Array(STATIC_INITIAL_BUFFER_SIZE),
  normals: new Float32Array(STATIC_INITIAL_BUFFER_SIZE)
};
function decodePolygon(geometry) {
  var breakpoints = []; // Array of indices (to vertexArray) that separate each feature

  var featureIDToVertexIndex = new Map();
  index = 0;

  for (var i = 0; i < geometry.length; i++) {
    var feature = geometry[i];

    var _loop = function _loop(j) {
      var polygon = feature[j];
      var triangles = earcut__WEBPACK_IMPORTED_MODULE_0__(polygon.flat, polygon.holes); // Increase buffers size if required

      resizeBuffers(VERTEX_COORDINATES_PER_TRIANGLE * triangles.length + MAX_VERTICES_COORDINATES_PER_SEGMENT * polygon.flat.length); // Add polygon

      for (var k = 0; k < triangles.length; k++) {
        addVertex(polygon.flat, 2 * triangles[k]);
      } // Add polygon stroke


      index = Object(_common__WEBPACK_IMPORTED_MODULE_1__["addLineString"])(polygon.flat, geomBuffer, index, true, function (pointIndex) {
        // Skip adding the line which connects two rings OR is clipped
        return polygon.holes.includes((pointIndex - 2) / 2) || isClipped(polygon, pointIndex - 4, pointIndex - 2);
      });
    };

    for (var j = 0; j < feature.length; j++) {
      _loop(j);
    }

    featureIDToVertexIndex.set(breakpoints.length, breakpoints.length === 0 ? {
      start: 0,
      end: index
    } : {
      start: featureIDToVertexIndex.get(breakpoints.length - 1).end,
      end: index
    });
    breakpoints.push(index);
  }

  var verticesArrayBuffer = new ArrayBuffer(4 * index);
  var normalsArrayBuffer = new ArrayBuffer(4 * index);
  var vertices = new Float32Array(verticesArrayBuffer);
  var normals = new Float32Array(normalsArrayBuffer);

  for (var _i = 0; _i < index; _i++) {
    vertices[_i] = geomBuffer.vertices[_i];
    normals[_i] = geomBuffer.normals[_i];
  }

  return {
    vertices: vertices,
    normals: normals,
    verticesArrayBuffer: verticesArrayBuffer,
    normalsArrayBuffer: normalsArrayBuffer,
    featureIDToVertexIndex: featureIDToVertexIndex,
    breakpoints: breakpoints
  };
} // Resize buffers as needed if `additionalSize` floats overflow the current buffers

function resizeBuffers(additionalSize) {
  var minimumNeededSize = index + additionalSize;

  if (minimumNeededSize > geomBuffer.vertices.length) {
    var newSize = 2 * minimumNeededSize;
    geomBuffer.vertices = Object(_common__WEBPACK_IMPORTED_MODULE_1__["resizeBuffer"])(geomBuffer.vertices, newSize);
    geomBuffer.normals = Object(_common__WEBPACK_IMPORTED_MODULE_1__["resizeBuffer"])(geomBuffer.normals, newSize);
  }
} // Add vertex in triangles.


function addVertex(array, vertexIndex) {
  geomBuffer.vertices[index] = array[vertexIndex];
  geomBuffer.normals[index++] = 0;
  geomBuffer.vertices[index] = array[vertexIndex + 1];
  geomBuffer.normals[index++] = 0;
}

function isClipped(polygon, i, j) {
  if (polygon.clipped.includes(i) && polygon.clipped.includes(j)) {
    if (polygon.clippedType[polygon.clipped.indexOf(i)] & polygon.clippedType[polygon.clipped.indexOf(j)]) {
      return true;
    }
  }

  return false;
}

/***/ }),

/***/ "./src/renderer/schema.js":
/*!********************************!*\
  !*** ./src/renderer/schema.js ***!
  \********************************/
/*! exports provided: IDENTITY, union, equals, CLUSTER_FEATURE_COUNT, column, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IDENTITY", function() { return IDENTITY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "union", function() { return union; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLUSTER_FEATURE_COUNT", function() { return CLUSTER_FEATURE_COUNT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "column", function() { return column; });
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var IDENTITY = {};
/*
const mns = {
    price:  [{type: 'unaggregated'}],
    amount: [{type: 'aggregated', op: 'avg'}, {type: 'aggregated', op: 'max'}}]
};

*/

function union(a, b) {
  var result = {};
  var propertyNames = new Set(Object.keys(a).concat(Object.keys(b)));
  propertyNames.forEach(function (propertyName) {
    var aUsages = a[propertyName] || [];
    var bUsages = b[propertyName] || [];

    var combinedUsage = _toConsumableArray(aUsages).concat(_toConsumableArray(bUsages));

    result[propertyName] = combinedUsage;
  });
  return result;
}
function equals(a, b) {
  if (!a || !b) {
    return false;
  }

  return JSON.stringify(simplify(a)) === JSON.stringify(simplify(b));
}

function simplify(MNS) {
  var result = {};
  var propertyNames = Object.keys(MNS).sort();
  propertyNames.forEach(function (propertyName) {
    // Stringify and Set to remove duplicates
    var usage = _toConsumableArray(new Set(MNS[propertyName].map(function (u) {
      return JSON.stringify(u);
    })));

    usage.sort();
    usage = usage.map(function (u) {
      return JSON.parse(u);
    });
    result[propertyName] = usage;
  });
  return result;
}

var AGG_PREFIX = '_cdb_agg_';
var AGG_PATTERN = new RegExp('^' + AGG_PREFIX + '[a-zA-Z0-9]+_');
var CLUSTER_FEATURE_COUNT = '_cdb_feature_count'; // column information functions

var column = {
  isAggregated: function isAggregated(name) {
    return name.startsWith(AGG_PREFIX);
  },
  getBase: function getBase(name) {
    return name.replace(AGG_PATTERN, '');
  },
  getAggFN: function getAggFN(name) {
    var s = name.substr(AGG_PREFIX.length);
    return s.substr(0, s.indexOf('_'));
  },
  aggColumn: function aggColumn(name, aggFN) {
    return "".concat(AGG_PREFIX).concat(aggFN, "_").concat(name);
  }
};
/* harmony default export */ __webpack_exports__["default"] = ({
  column: column,
  equals: equals,
  union: union,
  IDENTITY: IDENTITY,
  simplify: simplify
});

/***/ }),

/***/ "./src/sources/MVTWorker.js":
/*!**********************************!*\
  !*** ./src/sources/MVTWorker.js ***!
  \**********************************/
/*! exports provided: MVTWorker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MVTWorker", function() { return MVTWorker; });
/* harmony import */ var _mapbox_vector_tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mapbox/vector-tile */ "./node_modules/@mapbox/vector-tile/index.js");
/* harmony import */ var _mapbox_vector_tile__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mapbox_vector_tile__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pbf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pbf */ "./node_modules/pbf/index.js");
/* harmony import */ var pbf__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pbf__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _client_rsys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../client/rsys */ "./src/client/rsys.js");
/* harmony import */ var _client_mvt_feature_decoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../client/mvt/feature-decoder */ "./src/client/mvt/feature-decoder.js");
/* harmony import */ var _renderer_Metadata__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/Metadata */ "./src/renderer/Metadata.js");
/* harmony import */ var _renderer_DummyDataframe__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../renderer/DummyDataframe */ "./src/renderer/DummyDataframe.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }






 // TODO import correctly

var RTT_WIDTH = 1024; // Constants for '@mapbox/vector-tile' geometry types, from https://github.com/mapbox/vector-tile-js/blob/v1.3.0/lib/vectortilefeature.js#L39

var mvtDecoderGeomTypes = {
  point: 1,
  line: 2,
  polygon: 3
};
var geometryTypes = {
  UNKNOWN: 'unknown',
  POINT: 'point',
  LINE: 'line',
  POLYGON: 'polygon'
};
var MVT_TO_CARTO_TYPES = {
  1: geometryTypes.POINT,
  2: geometryTypes.LINE,
  3: geometryTypes.POLYGON
};
var MVTWorker =
/*#__PURE__*/
function () {
  function MVTWorker() {
    _classCallCheck(this, MVTWorker);
  }

  _createClass(MVTWorker, [{
    key: "onmessage",
    // Worker API
    value: function onmessage(event) {
      var _this = this;

      this.processEvent(event).then(function (message) {
        var transferables = [];

        if (!message.dataframe.empty) {
          transferables.push(_this._propertiesArrayBuffer);
          transferables.push(message.dataframe.decodedGeom.verticesArrayBuffer);

          if (message.dataframe.decodedGeom.normalsArrayBuffer) {
            transferables.push(message.dataframe.decodedGeom.normalsArrayBuffer);
          }
        }

        postMessage(message, transferables);
      });
    }
  }, {
    key: "processEvent",
    value: function () {
      var _processEvent = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(event) {
        var params, dataframe;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                params = event.data;

                if (params.metadata) {
                  Object.setPrototypeOf(params.metadata, _renderer_Metadata__WEBPACK_IMPORTED_MODULE_4__["default"].prototype);
                  this.metadata = params.metadata;
                }

                _context.next = 4;
                return this._requestDataframe(params.x, params.y, params.z, params.url, params.layerID, this.metadata);

              case 4:
                dataframe = _context.sent;
                return _context.abrupt("return", {
                  mID: params.mID,
                  dataframe: dataframe
                });

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function processEvent(_x) {
        return _processEvent.apply(this, arguments);
      };
    }()
  }, {
    key: "_requestDataframe",
    value: function () {
      var _requestDataframe2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(x, y, z, url, layerID, metadata) {
        var response, dataframe;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return fetch(url);

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return this.urlToDataframeTransformer(response, x, y, z, layerID, metadata);

              case 5:
                dataframe = _context2.sent;
                return _context2.abrupt("return", dataframe);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function _requestDataframe(_x2, _x3, _x4, _x5, _x6, _x7) {
        return _requestDataframe2.apply(this, arguments);
      };
    }()
  }, {
    key: "urlToDataframeTransformer",
    value: function () {
      var _urlToDataframeTransformer = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(response, x, y, z, layerID, metadata) {
        var MVT_EXTENT, arrayBuffer, tile, mvtLayer, _this$_decodeMVTLayer, geometries, properties, numFeatures, rs, dataframe;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                MVT_EXTENT = 4096;
                _context3.next = 3;
                return response.arrayBuffer();

              case 3:
                arrayBuffer = _context3.sent;

                if (!(arrayBuffer.byteLength === 0 || response === 'null')) {
                  _context3.next = 6;
                  break;
                }

                return _context3.abrupt("return", {
                  empty: true
                });

              case 6:
                tile = new _mapbox_vector_tile__WEBPACK_IMPORTED_MODULE_0__["VectorTile"](new pbf__WEBPACK_IMPORTED_MODULE_1__(arrayBuffer));

                if (!(Object.keys(tile.layers).length > 1 && !layerID)) {
                  _context3.next = 9;
                  break;
                }

                throw new Error("LayerID parameter wasn't specified and the MVT tile contains multiple layers: ".concat(JSON.stringify(Object.keys(tile.layers))));

              case 9:
                mvtLayer = tile.layers[layerID || Object.keys(tile.layers)[0]]; // FIXME this!!!

                if (mvtLayer) {
                  _context3.next = 12;
                  break;
                }

                return _context3.abrupt("return", {
                  empty: true
                });

              case 12:
                _this$_decodeMVTLayer = this._decodeMVTLayer(mvtLayer, metadata, MVT_EXTENT), geometries = _this$_decodeMVTLayer.geometries, properties = _this$_decodeMVTLayer.properties, numFeatures = _this$_decodeMVTLayer.numFeatures;
                rs = _client_rsys__WEBPACK_IMPORTED_MODULE_2__["getRsysFromTile"](x, y, z);
                dataframe = this._generateDataFrame(rs, geometries, properties, numFeatures, metadata.geomType, metadata);
                return _context3.abrupt("return", dataframe);

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function urlToDataframeTransformer(_x8, _x9, _x10, _x11, _x12, _x13) {
        return _urlToDataframeTransformer.apply(this, arguments);
      };
    }()
  }, {
    key: "_decodeMVTLayer",
    value: function _decodeMVTLayer(mvtLayer, metadata, mvtExtent) {
      if (!mvtLayer.length) {
        return {
          properties: [],
          geometries: {},
          numFeatures: 0
        };
      }

      if (!metadata.geomType) {
        metadata.geomType = this._autoDiscoverType(mvtLayer);
      }

      switch (metadata.geomType) {
        case geometryTypes.POINT:
          var arrayBuffer = new ArrayBuffer(mvtLayer.length * 2 * 3 * 4); // SIZEOF

          return this._decode(mvtLayer, metadata, mvtExtent, arrayBuffer);

        case geometryTypes.LINE:
          return this._decode(mvtLayer, metadata, mvtExtent, [], _client_mvt_feature_decoder__WEBPACK_IMPORTED_MODULE_3__["decodeLines"]);

        case geometryTypes.POLYGON:
          return this._decode(mvtLayer, metadata, mvtExtent, [], _client_mvt_feature_decoder__WEBPACK_IMPORTED_MODULE_3__["decodePolygons"]);

        default:
          throw new Error('MVT: invalid geometry type');
      }
    }
  }, {
    key: "_autoDiscoverType",
    value: function _autoDiscoverType(mvtLayer) {
      var type = mvtLayer.feature(0).type;

      switch (type) {
        case mvtDecoderGeomTypes.point:
          return geometryTypes.POINT;

        case mvtDecoderGeomTypes.line:
          return geometryTypes.LINE;

        case mvtDecoderGeomTypes.polygon:
          return geometryTypes.POLYGON;

        default:
          throw new Error('MVT: invalid geometry type');
      }
    }
  }, {
    key: "_decode",
    value: function _decode(mvtLayer, metadata, mvtExtent, geometries, decodeFn) {
      var numFeatures = 0;
      var pointGeometries;

      if (geometries) {
        pointGeometries = new Float32Array(geometries);
      }

      var _this$_initializeProp = this._initializePropertyArrays(metadata, mvtLayer.length),
          properties = _this$_initializeProp.properties,
          propertyNames = _this$_initializeProp.propertyNames;

      for (var i = 0; i < mvtLayer.length; i++) {
        var f = mvtLayer.feature(i);

        this._checkType(f, metadata.geomType);

        var geom = f.loadGeometry();

        if (decodeFn) {
          var decodedPolygons = decodeFn(geom, mvtExtent);
          geometries.push(decodedPolygons);
        } else {
          // TODO refactor
          var x = 2 * geom[0][0].x / mvtExtent - 1.0;
          var y = 2 * (1.0 - geom[0][0].y / mvtExtent) - 1.0; // Tiles may contain points in the border;
          // we'll avoid here duplicated points between tiles by excluding the 1-edge

          if (x < -1 || x >= 1 || y < -1 || y >= 1) {
            continue;
          }

          pointGeometries[6 * numFeatures + 0] = x;
          pointGeometries[6 * numFeatures + 1] = y;
          pointGeometries[6 * numFeatures + 2] = x;
          pointGeometries[6 * numFeatures + 3] = y;
          pointGeometries[6 * numFeatures + 4] = x;
          pointGeometries[6 * numFeatures + 5] = y;
        }

        if (f.properties[metadata.idProperty] === undefined) {
          throw new Error("MVT feature with undefined idProperty '".concat(metadata.idProperty, "'"));
        }

        this._decodeProperties(metadata, propertyNames, properties, f, numFeatures);

        numFeatures++;
      }

      return {
        properties: properties,
        geometries: geometries,
        numFeatures: numFeatures
      };
    } // Currently only mvtLayers with the same type in every feature are supported

  }, {
    key: "_checkType",
    value: function _checkType(feature, expected) {
      var type = feature.type;
      var actual = MVT_TO_CARTO_TYPES[type];

      if (actual !== expected) {
        throw new Error("MVT: mixed geometry types in the same layer. Layer has type: ".concat(expected, " but feature was ").concat(actual));
      }
    }
  }, {
    key: "_initializePropertyArrays",
    value: function _initializePropertyArrays(metadata, length) {
      var propertyNames = this._getPropertyNamesFrom(metadata);

      var properties = this._getPropertiesFor(propertyNames, length);

      return {
        propertyNames: propertyNames,
        properties: properties
      };
    }
  }, {
    key: "_getPropertyNamesFrom",
    value: function _getPropertyNamesFrom(metadata) {
      var propertyNames = [];

      for (var i = 0; i < metadata.propertyKeys.length; i++) {
        var propertyName = metadata.propertyKeys[i];

        if (metadata.properties[propertyName].type === 'geometry') {
          continue;
        }

        propertyNames.push.apply(propertyNames, _toConsumableArray(metadata.propertyNames(propertyName)));
      }

      return propertyNames;
    }
  }, {
    key: "_getPropertiesFor",
    value: function _getPropertiesFor(propertyNames, length) {
      var properties = {};
      var size = Math.ceil(length / RTT_WIDTH) * RTT_WIDTH;
      var arrayBuffer = new ArrayBuffer(4 * size * propertyNames.length);
      this._propertiesArrayBuffer = arrayBuffer;

      for (var i = 0; i < propertyNames.length; i++) {
        var propertyName = propertyNames[i];
        properties[propertyName] = new Float32Array(arrayBuffer, i * 4 * size, size);
      }

      return properties;
    }
  }, {
    key: "_decodeProperties",
    value: function _decodeProperties(metadata, propertyNames, properties, feature, i) {
      var length = propertyNames.length;

      for (var j = 0; j < length; j++) {
        var propertyName = propertyNames[j];
        var propertyValue = feature.properties[propertyName];
        properties[propertyName][i] = this.decodeProperty(metadata, propertyName, propertyValue);
      }
    }
  }, {
    key: "decodeProperty",
    value: function decodeProperty(metadata, propertyName, propertyValue) {
      if (typeof propertyValue === 'string') {
        if (metadata.properties[propertyName].type !== 'category') {
          throw new Error("MVT decoding error. Metadata property '".concat(propertyName, "' is of type '").concat(metadata.properties[propertyName].type, "' but the MVT tile contained a feature property of type string: '").concat(propertyValue, "'"));
        }

        return metadata.categorizeString(propertyName, propertyValue);
      } else if (typeof propertyValue === 'number') {
        if (metadata.properties[propertyName].type !== 'number') {
          throw new Error("MVT decoding error. Metadata property '".concat(propertyName, "' is of type '").concat(metadata.properties[propertyName].type, "' but the MVT tile contained a feature property of type number: '").concat(propertyValue, "'"));
        }

        return propertyValue;
      } else if (propertyValue === null || propertyValue === undefined) {
        return Number.NaN;
      } else {
        throw new Error("MVT decoding error. Feature property value of type '".concat(_typeof(propertyValue), "' cannot be decoded."));
      }
    }
  }, {
    key: "_generateDataFrame",
    value: function _generateDataFrame(rs, geometry, properties, size, type, metadata) {
      return new _renderer_DummyDataframe__WEBPACK_IMPORTED_MODULE_5__["default"]({
        active: false,
        center: rs.center,
        geom: geometry,
        properties: properties,
        scale: rs.scale,
        size: size,
        type: type,
        metadata: metadata
      });
    }
  }]);

  return MVTWorker;
}();

/***/ }),

/***/ "./src/sources/MVTWorkers.worker.js":
/*!******************************************!*\
  !*** ./src/sources/MVTWorkers.worker.js ***!
  \******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MVTWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MVTWorker */ "./src/sources/MVTWorker.js");
/* harmony import */ var _client_WindshaftWorker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../client/WindshaftWorker */ "./src/client/WindshaftWorker.js");



// This file publishes a Web Worker onmessage function that will redirect incoming messages
// based on an ID (`workerName`) defined by the message sender
// to each different Worker implementation

const workers = {
    MVT: new _MVTWorker__WEBPACK_IMPORTED_MODULE_0__["MVTWorker"](),
    windshaft: new _client_WindshaftWorker__WEBPACK_IMPORTED_MODULE_1__["WindshaftWorker"]()
};

onmessage = function (event) {
    return workers[event.data.workerName].onmessage(event);
};


/***/ }),

/***/ "./src/utils/geometry.js":
/*!*******************************!*\
  !*** ./src/utils/geometry.js ***!
  \*******************************/
/*! exports provided: intersect, sub, dot, perpendicular, getLineNormal, getJoinNormal, neg, pointInTriangle, halfPlaneSign, equalPoints, pointInCircle, pointInRectangle, computeAABB, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersect", function() { return intersect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perpendicular", function() { return perpendicular; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLineNormal", function() { return getLineNormal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getJoinNormal", function() { return getJoinNormal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "neg", function() { return neg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointInTriangle", function() { return pointInTriangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "halfPlaneSign", function() { return halfPlaneSign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equalPoints", function() { return equalPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointInCircle", function() { return pointInCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointInRectangle", function() { return pointInRectangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeAABB", function() { return computeAABB; });
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// If AB intersects CD => return intersection point
// Intersection method from Real Time Rendering, Third Edition, page 780
function intersect(a, b, c, d) {
  var o1 = a;
  var o2 = c;
  var d1 = sub(b, a);
  var d2 = sub(d, c);
  var d1t = perpendicular(d1);
  var d2t = perpendicular(d2);
  var s = dot(sub(o2, o1), d2t) / dot(d1, d2t);
  var t = dot(sub(o1, o2), d1t) / dot(d2, d1t);

  if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
    return [o1[0] + s * d1[0], o1[1] + s * d1[1]];
  }
}
function sub(_ref, _ref2) {
  var _ref3 = _slicedToArray(_ref, 2),
      ax = _ref3[0],
      ay = _ref3[1];

  var _ref4 = _slicedToArray(_ref2, 2),
      bx = _ref4[0],
      by = _ref4[1];

  return [ax - bx, ay - by];
}
function dot(_ref5, _ref6) {
  var _ref7 = _slicedToArray(_ref5, 2),
      ax = _ref7[0],
      ay = _ref7[1];

  var _ref8 = _slicedToArray(_ref6, 2),
      bx = _ref8[0],
      by = _ref8[1];

  return ax * bx + ay * by;
}
function perpendicular(_ref9) {
  var _ref10 = _slicedToArray(_ref9, 2),
      x = _ref10[0],
      y = _ref10[1];

  return [-y, x];
}
/**
 * Compute the normal of a line AB.
 * By definition it is the unitary vector from B to A, rotated +90 degrees counter-clockwise
 */

function getLineNormal(a, b) {
  var u = normalize(a[0] - b[0], a[1] - b[1]);
  return [-u[1], u[0]];
}
/**
 * Compute the normal of the join from the lines' normals.
 * By definition this is the sum of the unitary vectors `u` (from B to A) and `v` (from B to C)
 * multiplied by a factor of `1/sin(theta)` to reach the intersection of the wide lines.
 * Theta is the angle between the vectors `v` and `u`. But instead of computing the angle,
 * the `sin(theta)` (with sign) is obtained directly from the vectorial product of `v` and `u`
 */

function getJoinNormal(prevNormal, nextNormal) {
  var u = [prevNormal[1], -prevNormal[0]];
  var v = [-nextNormal[1], nextNormal[0]];
  var sin = v[0] * u[1] - v[1] * u[0];
  var cos = v[0] * u[0] + v[1] * u[1];
  var factor = Math.abs(sin);
  var miterJoin = !(factor < 0.866 && cos > 0.5); // 60 deg

  return {
    turnLeft: sin > 0,
    joinNormal: miterJoin && neg([(u[0] + v[0]) / factor, (u[1] + v[1]) / factor])
  };
}
/**
 * Return the negative of the provided vector
 */

function neg(v) {
  return [-v[0], -v[1]];
}
/**
 * Return the vector scaled to length 1
 */

function normalize(x, y) {
  var s = Math.hypot(x, y);
  return [x / s, y / s];
} // Returns true if p is inside the triangle or on a triangle's edge, false otherwise
// Parameters in {x: 0, y:0} form


function pointInTriangle(p, v1, v2, v3) {
  // https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle
  // contains an explanation of both this algorithm and one based on barycentric coordinates,
  // which could be faster, but, nevertheless, it is quite similar in terms of required arithmetic operations
  if (equalPoints(v1, v2) || equalPoints(v2, v3) || equalPoints(v3, v1)) {
    // Avoid zero area triangle
    return false;
  } // A point is inside a triangle or in one of the triangles edges
  // if the point is in the three half-plane defined by the 3 edges


  var b1 = halfPlaneSign(p, v1, v2) < 0;
  var b2 = halfPlaneSign(p, v2, v3) < 0;
  var b3 = halfPlaneSign(p, v3, v1) < 0;
  return b1 === b2 && b2 === b3;
} // Tests if a point `p` is in the half plane defined by the line with points `a` and `b`
// Returns a negative number if the result is INSIDE, returns 0 if the result is ON_LINE,
// returns >0 if the point is OUTSIDE
// Parameters in {x: 0, y:0} form

function halfPlaneSign(p, a, b) {
  // We use the cross product of `PB x AB` to get `sin(angle(PB, AB))`
  // The result's sign is the half plane test result
  return (p.x - b.x) * (a.y - b.y) - (a.x - b.x) * (p.y - b.y);
}
function equalPoints(a, b) {
  return a.x === b.x && a.y === b.y;
}
function pointInCircle(p, center, scale) {
  var diff = {
    x: p.x - center.x,
    y: p.y - center.y
  };
  var lengthSquared = diff.x * diff.x + diff.y * diff.y;
  return lengthSquared <= scale * scale;
}
function pointInRectangle(point, bbox) {
  if (bbox === null) {
    return false;
  }

  var p = {
    x: point.x.toFixed(2),
    y: point.y.toFixed(2)
  };
  return bbox.minx <= p.x && p.x <= bbox.maxx && bbox.miny <= p.y && p.y <= bbox.maxy;
}
function computeAABB(geometry, type) {
  switch (type) {
    case 'point':
      return [];

    case 'line':
    case 'polygon':
      var aabbList = [];

      for (var i = 0; i < geometry.length; i++) {
        var feature = geometry[i];
        var aabb = {
          minx: Number.POSITIVE_INFINITY,
          miny: Number.POSITIVE_INFINITY,
          maxx: Number.NEGATIVE_INFINITY,
          maxy: Number.NEGATIVE_INFINITY
        };

        for (var j = 0; j < feature.length; j++) {
          aabb = _updateAABBForGeometry(feature[j], aabb, type);
        }

        if (aabb.minx === Number.POSITIVE_INFINITY) {
          aabb = null;
        }

        aabbList.push(aabb);
      }

      return aabbList;
  }
}

function _updateAABBForGeometry(feature, aabb, geometryType) {
  switch (geometryType) {
    case 'line':
      return _updateAABBLine(feature, aabb);

    case 'polygon':
      return _updateAABBPolygon(feature, aabb);
  }
}

function _updateAABBLine(line, aabb) {
  var vertices = line;
  var numVertices = line.length;

  for (var i = 0; i < numVertices; i += 2) {
    aabb.minx = Math.min(aabb.minx, vertices[i + 0]);
    aabb.miny = Math.min(aabb.miny, vertices[i + 1]);
    aabb.maxx = Math.max(aabb.maxx, vertices[i + 0]);
    aabb.maxy = Math.max(aabb.maxy, vertices[i + 1]);
  }

  return aabb;
}

function _updateAABBPolygon(polygon, aabb) {
  var _ref11 = [polygon.flat, polygon.holes[0] || polygon.flat.length / 2],
      vertices = _ref11[0],
      numVertices = _ref11[1];

  for (var i = 0; i < numVertices; i++) {
    aabb.minx = Math.min(aabb.minx, vertices[2 * i + 0]);
    aabb.miny = Math.min(aabb.miny, vertices[2 * i + 1]);
    aabb.maxx = Math.max(aabb.maxx, vertices[2 * i + 0]);
    aabb.maxy = Math.max(aabb.maxy, vertices[2 * i + 1]);
  }

  return aabb;
}

/* harmony default export */ __webpack_exports__["default"] = ({
  intersect: intersect,
  sub: sub,
  dot: dot,
  perpendicular: perpendicular,
  getLineNormal: getLineNormal,
  getJoinNormal: getJoinNormal,
  neg: neg,
  halfPlaneSign: halfPlaneSign,
  pointInTriangle: pointInTriangle,
  equalPoints: equalPoints,
  pointInCircle: pointInCircle,
  pointInRectangle: pointInRectangle
});

/***/ })

/******/ });
//# sourceMappingURL=4e311e46cb430789c27c.worker.js.map