{"version":3,"sources":["webpack://carto/webpack/bootstrap","webpack://carto/./src/client/WindshaftWorker.js","webpack://carto/./src/client/mvt/feature-decoder.js","webpack://carto/./src/client/rsys.js","webpack://carto/./src/renderer/DummyDataframe.js","webpack://carto/./src/renderer/Metadata.js","webpack://carto/./src/renderer/decoder/common.js","webpack://carto/./src/renderer/decoder/index.js","webpack://carto/./src/renderer/decoder/lineDecoder.js","webpack://carto/./src/renderer/decoder/pointDecoder.js","webpack://carto/./src/renderer/decoder/polygonDecoder.js","webpack://carto/./src/renderer/schema.js","webpack://carto/./src/sources/MVTWorker.js","webpack://carto/./src/sources/MVTWorkers.worker.js","webpack://carto/./src/utils/geometry.js"],"names":[],"mappings":";;;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAiD;AACT;;AAEjC,8BAA8B,4DAAS;AAC9C;AACA,yBAAyB,wDAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,qBAAqB;AACtH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiD;AAC1C;AACP;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA,6BAA6B,uDAAa;AAC1C,KAAK;AACL;AACA,oBAAoB;AACpB;AACA,6BAA6B,uDAAa;AAC1C,KAAK;AACL;AACA,qBAAqB;AACrB;AACA,6BAA6B,uDAAa;AAC1C,KAAK;AACL;AACA,uBAAuB;AACvB;AACA,6BAA6B,uDAAa;AAC1C;AACA;AACA;;AAEO;AACP;AACA;;AAEA;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA,cAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7RA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,YAAY,OAAO;AACnB;AACO;AACP,YAAY;AACZ;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA,YAAY,0BAA0B,yDAAyD;AAC/F;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,YAAY,MAAM,sBAAsB;AACxC;AACO;AACP;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,YAAY,MAAM,sBAAsB;AACxC;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC,2BAA2B,YAAY;AACvC,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEe,gEAAC,gCAAgC,EAAC;;;;;;;;;;;;;AClIjD;AAAA;AAAA;AAAA;AAAuC;AACS;;AAEjC;AACf,kBAAkB,gEAAgE;AAClF;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mEAAW;AAChC;AACA;;;;;;;;;;;;;;;;;ACnBA;AACO;AACP;AACA;;AAEe;AACf,kBAAkB,uEAAuE,IAAI,eAAe,EAAE;AAC9G;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnDA;AAAA;AAAA;AAAA;AAAyE;;AAEzE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAa;;AAElC,uBAAuB,wBAAwB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,6BAA6B,qEAAa;;AAE1C;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB,GAAG,qEAAa;;AAE9D,6DAA6D,2DAAG;AAChE,8DAA8D,2DAAG;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;AC3HA;AAAA;AAAA;AAAA;AAAA;AAA6C;AACF;AACM;;AAE1C;AACP;AACA;AACA,mBAAmB,iEAAW;AAC9B;AACA,mBAAmB,+DAAU;AAC7B;AACA,mBAAmB,qEAAa;AAChC;AACA,6DAA6D,SAAS;AACtE;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAuD;;AAEvD;AACA;;AAEA,+CAA+C;AAC/C;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP,yBAAyB;AACzB;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA,uBAAuB,oBAAoB;AAC3C;AACA;;AAEA;AACA,oBAAoB,6DAAa;AACjC;;AAEA;AACA,eAAe;AACf,eAAe,4EAA4E;;AAE3F;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4DAAY;AAC1C,6BAA6B,4DAAY;AACzC;AACA;;;;;;;;;;;;;AC9DA;AAAA;AAAA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;AAAiC;AACsB;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA,mDAAmD;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP,yBAAyB;AACzB;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA,uBAAuB,oBAAoB;AAC3C;AACA,8BAA8B,mCAAM;;AAEpC;AACA;AACA;;AAEA;AACA,2BAA2B,sBAAsB;AACjD;AACA;;AAEA;AACA,oBAAoB,6DAAa;AACjC;AACA;AACA,aAAa;AACb;;AAEA;AACA,eAAe;AACf,eAAe,4EAA4E;;AAE3F;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4DAAY;AAC1C,6BAA6B,4DAAY;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtGO;;AAEP;AACA;AACA,cAAc,qBAAqB;AACnC,cAAc,8BAA8B,GAAG,+BAA+B;AAC9E;;AAEA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEO;;AAEP;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAkB,WAAW,EAAE,MAAM,GAAG,KAAK;AAC7C;AACA;;AAEe,gEAAC,4CAA4C,EAAC;;;;;;;;;;;;;ACjE7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiD;AACjB;AACO;AACqC;AAChC;AACY;;AAExD;AACA;;AAEA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mDAAmD,0DAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,yBAAyB,8DAAU,KAAK,gCAAQ;;AAEhD;AACA,6GAA6G,yCAAyC;AACtJ;;AAEA,6EAA6E;;AAE7E;AACA,oBAAoB;AACpB;;AAEA,eAAe,sCAAsC;AACrD,mBAAmB,4DAAoB;AACvC;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA,uEAAuE,uEAAW;AAClF;AACA,uEAAuE,0EAAc;AACrF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,oBAAoB;AAC9F;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA,4FAA4F,SAAS,mBAAmB,OAAO;AAC/H;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA,uBAAuB,kCAAkC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0EAA0E,aAAa,gBAAgB,uCAAuC,mEAAmE,cAAc;AAC/N;AACA;AACA,SAAS;AACT;AACA,0EAA0E,aAAa,gBAAgB,uCAAuC,mEAAmE,cAAc;AAC/N;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,mFAAmF,qBAAqB;AACxG;AACA;;AAEA;AACA,mBAAmB,gEAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;AC/OA;AAAA;AAAA;AAAwC;AACoB;;AAE5D;AACA;AACA;;AAEA;AACA,aAAa,oDAAS;AACtB,mBAAmB,uEAAe;AAClC;;AAEA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,UAAU;AACrB;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,UAAU;AACrB;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,qBAAqB;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,oBAAoB;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC","file":"48c70242485248478196.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/sources/MVTWorkers.worker.js\");\n","import { MVTWorker } from '../sources/MVTWorker';\nimport schema from '../renderer/schema';\n\nexport class WindshaftWorker extends MVTWorker {\n    decodeProperty (metadata, propertyName, propertyValue) {\n        const basename = schema.column.getBase(propertyName);\n        const column = metadata.properties[basename];\n        if (!column) {\n            return;\n        }\n        switch (column.type) {\n            case 'date':\n                return decodeDate(column, propertyValue);\n            case 'category':\n                return metadata.categorizeString(basename, propertyValue);\n            case 'number':\n                return propertyValue;\n            default:\n                throw new Error(`Windshaft MVT decoding error. Feature property value of type '${typeof propertyValue}' cannot be decoded.`);\n        }\n    }\n}\n\nfunction decodeDate (column, propertyValue) {\n    const d = new Date();\n    d.setTime(1000 * propertyValue);\n    const {min, max} = column;\n    const n = (d - min) / (max.getTime() - min.getTime());\n    return n;\n}\n","import geometryUtils from '../../utils/geometry';\nexport class Polygon {\n    constructor () {\n        this.flat = [];\n        this.holes = [];\n        this.clipped = [];\n        this.clippedType = []; // Store a bitmask of the clipped half-planes\n    }\n}\n\nexport function decodeLines (geometries, mvtExtent) {\n    let decodedGeometries = [];\n    geometries.map(l => {\n        let line = [];\n        l.map(point => {\n            line.push([2 * point.x / mvtExtent - 1, 2 * (1 - point.y / mvtExtent) - 1]);\n        });\n        decodedGeometries.push(...clipLine(line));\n    });\n    return decodedGeometries;\n}\n\n/*\n    All this clockwise non-sense is needed because the MVT decoder dont decode the MVT fully.\n    It doesn't distinguish between internal polygon rings (which defines holes) or external ones, which defines more polygons (mulipolygons)\n    See:\n        https://github.com/mapbox/vector-tile-spec/tree/master/2.1\n        https://en.wikipedia.org/wiki/Shoelace_formula\n*/\nexport function decodePolygons (geometries, mvtExtent) {\n    let currentPolygon = null;\n    let decoded = [];\n    let invertedOrientation;\n    geometries.forEach(geom => {\n        let area = signedPolygonArea(geom);\n        if (area === 0) {\n            return;\n        }\n        if (invertedOrientation === undefined) {\n            // According to the MVT spec this condition cannot happen for\n            // MVT spec compliant tiles, but many buggy implementations\n            // don't comply with this rule when generating tiles\n            // Also, other implementations accept this out-of-the-spec condition\n            invertedOrientation = area > 0;\n        }\n        const isExternalPolygon = invertedOrientation ? area > 0 : area < 0;\n\n        const preClippedVertices = _getPreClippedVertices(geom, mvtExtent);\n\n        if (isExternalPolygon) {\n            if (currentPolygon) {\n                decoded.push(currentPolygon);\n            }\n\n            currentPolygon = new Polygon();\n        }\n\n        currentPolygon = clipPolygon(preClippedVertices, currentPolygon, !isExternalPolygon);\n    });\n\n    if (currentPolygon) {\n        decoded.push(currentPolygon);\n    }\n\n    return decoded;\n}\n\nexport function signedPolygonArea (vertices) {\n    // https://en.wikipedia.org/wiki/Shoelace_formula\n    let a = 0;\n    for (let i = 0; i < vertices.length; i++) {\n        let j = (i + 1) % vertices.length;\n        a += vertices[i].x * vertices[j].y;\n        a -= vertices[j].x * vertices[i].y;\n    }\n    return a / 2;\n}\n\nconst CLIPMAX = 1;\nconst CLIPMIN = -CLIPMAX;\n\nconst clippingEdges = [\n    {\n        // Right edge; x <= CLIPMAX for points inside\n        inside: p => p[0] <= CLIPMAX,\n        intersect: (a, b) => geometryUtils.intersect(a, b, [CLIPMAX, -100], [CLIPMAX, 100])\n    },\n    {\n        // Top edge; y <= CLIPMAX for points inside\n        inside: p => p[1] <= CLIPMAX,\n        intersect: (a, b) => geometryUtils.intersect(a, b, [-100, CLIPMAX], [100, CLIPMAX])\n    },\n    {\n        // Left edge; x >= CLIPMIN for points inside\n        inside: p => p[0] >= CLIPMIN,\n        intersect: (a, b) => geometryUtils.intersect(a, b, [CLIPMIN, -100], [CLIPMIN, 100])\n    },\n    {\n        // Bottom edge; y >= CLIPMIN for points inside\n        inside: p => p[1] >= CLIPMIN,\n        intersect: (a, b) => geometryUtils.intersect(a, b, [-100, CLIPMIN], [100, CLIPMIN])\n    }\n];\nconst numberOfEdges = clippingEdges.length;\n\nexport function clipPolygon (preClippedVertices, polygon, isHole) {\n    // Sutherland-Hodgman Algorithm to clip polygons to the tile\n    // https://www.cs.drexel.edu/~david/Classes/CS430/Lectures/L-05_Polygons.6.pdf\n\n    let clippedTypes = {};\n\n    // for each clipping edge\n    for (let i = 0; i < numberOfEdges; i++) {\n        const preClippedVertices2 = [];\n        const clippedTypes2 = {};\n\n        const setClippedType = (vertexIndex, oldVertexIndex, edge = -1) => {\n            let clippedType = 0;\n            if (oldVertexIndex >= 0) {\n                clippedType = clippedTypes[oldVertexIndex] || 0;\n            }\n            if (edge >= 0) {\n                clippedType = clippedType | (1 << edge);\n            }\n            if (clippedType) {\n                clippedTypes2[vertexIndex] = clippedType;\n            }\n        };\n\n        // for each edge on polygon\n        for (let k = 0; k < preClippedVertices.length - 1; k++) {\n            // clip polygon edge\n            const a = preClippedVertices[k];\n            const b = preClippedVertices[k + 1];\n\n            const insideA = clippingEdges[i].inside(a);\n            const insideB = clippingEdges[i].inside(b);\n\n            if (insideA && insideB) {\n                // case 1: both inside, push B vertex\n                setClippedType(preClippedVertices2.length, k + 1);\n                preClippedVertices2.push(b);\n            } else if (insideA) {\n                // case 2: just B outside, push intersection\n                const intersectionPoint = clippingEdges[i].intersect(a, b);\n                setClippedType(preClippedVertices2.length, k + 1, i);\n                preClippedVertices2.push(intersectionPoint);\n            } else if (insideB) {\n                // case 4: just A outside: push intersection, push B\n                const intersectionPoint = clippingEdges[i].intersect(a, b);\n                setClippedType(preClippedVertices2.length, k, i);\n                preClippedVertices2.push(intersectionPoint);\n                setClippedType(preClippedVertices2.length, k + 1);\n                preClippedVertices2.push(b);\n            } else {\n                // case 3: both outside: do nothing\n            }\n        }\n        if (preClippedVertices2.length) {\n            if (clippedTypes2[0]) {\n                clippedTypes2[preClippedVertices2.length] = clippedTypes2[0];\n            }\n            preClippedVertices2.push(preClippedVertices2[0]);\n        }\n        preClippedVertices = preClippedVertices2;\n        clippedTypes = clippedTypes2;\n    }\n\n    // rings with less than 3 vertices are degenerate\n    const MIN_VALID_NUM_VERTICES = 3;\n\n    // preClippedVertices is closed by repeating the first vertex\n    if (preClippedVertices.length >= MIN_VALID_NUM_VERTICES + 1) {\n        if (isHole) {\n            polygon.holes.push(polygon.flat.length / 2);\n        }\n        preClippedVertices.forEach(v => {\n            polygon.flat.push(v[0], v[1]);\n        });\n        Object.keys(clippedTypes).forEach(i => {\n            polygon.clipped.push(Number(i) * 2);\n            polygon.clippedType.push(clippedTypes[i]);\n        });\n    }\n\n    return polygon;\n}\n\nfunction _getPreClippedVertices (geom, mvtExtent) {\n    return geom.map((coord) => {\n        let x = coord.x;\n        let y = coord.y;\n\n        x = 2 * x / mvtExtent - 1;\n        y = 2 * (1 - y / mvtExtent) - 1;\n\n        return [x, y];\n    });\n}\n\nfunction clipLine (line) {\n    // linestring clipping based on the Cohen-Sutherland algorithm\n    // input is a single linestring [point0, point1, ...]\n    // output is an array of flat linestrings:\n    // [[p0x, p0y, p1x, p1y, ...], ...]\n    let clippedLine = [];\n    const clippedLines = [];\n    function clipType (point) {\n        let type = 0;\n        for (let i = 0; i < numberOfEdges; i++) {\n            type = type | (clippingEdges[i].inside(point) ? 0 : (1 << i));\n        }\n        return type;\n    }\n    function intersect (point1, point2, type) {\n        for (let i = 0; i < numberOfEdges; i++) {\n            const mask = 1 << i;\n            if (type & mask) {\n                const p = clippingEdges[i].intersect(point1, point2);\n                type = clipType(p) & ~mask;\n                return [p, type];\n            }\n        }\n    }\n    let point0 = line[0];\n    let type0 = clipType(point0);\n    for (let i = 1; i < line.length; ++i) {\n        let point1 = line[i];\n        let type1 = clipType(point1);\n        const nextType = type1;\n        const nextPoint = point1;\n\n        for (; ;) {\n            if (!(type0 | type1)) {\n                // both points inside\n                clippedLine.push(...point0);\n                if (type1 !== nextType) {\n                    clippedLine.push(...point1);\n                    if (i < line.length - 1) {\n                        // break line\n                        clippedLines.push(clippedLine);\n                        clippedLine = [];\n                    }\n                } else if (i === line.length - 1) {\n                    clippedLine.push(...point1);\n                }\n                break;\n            } else if (type0 & type1) {\n                // both points outside\n                break;\n            } else if (type0) {\n                // only point1 inside\n                [point0, type0] = intersect(point0, point1, type0);\n            } else {\n                // only point0 inside\n                [point1, type1] = intersect(point0, point1, type1);\n            }\n        }\n\n        point0 = nextPoint;\n        type0 = nextType;\n    }\n\n    clippedLine = _removeDuplicatedVerticesOnLine(clippedLine);\n    if (clippedLine.length > 0) {\n        clippedLines.push(clippedLine);\n    }\n\n    return clippedLines;\n}\n\nfunction _removeDuplicatedVerticesOnLine (line) {\n    const result = [];\n    let prevX;\n    let prevY;\n    for (let i = 0; i < line.length; i += 2) {\n        const x = line[i];\n        const y = line[i + 1];\n        if (x !== prevX || y !== prevY) {\n            result.push(x, y);\n            prevX = x;\n            prevY = y;\n        }\n    }\n    return result;\n}\n","/**\n * An RSys defines a local coordinate system that maps the coordinates\n * in the range -1 <= x <= +1; -1 <= y <= +1 to an arbitrary rectangle\n * in an external coordinate system. (e.g. Dataframe coordinates to World coordinates)\n * It is the combination of a translation and anisotropic scaling.\n * @typedef {object} RSys - Renderer relative coordinate system\n * @property {RPoint} center - Position of the local system in external coordinates\n * @property {number} scale - Y-scale (local Y-distance / external Y-distance)\n*/\n\n/*\n * Random notes\n *\n * We can redefine Dataframe to use a Rsys instead of center, scale\n * and we can use an Rsys for the Renderer's canvas.\n *\n * Some interesting World coordinate systems:\n *\n * WM (Webmercator): represents a part of the world (excluding polar regions)\n * with coordinates in the range +/-WM_R for both X and Y. (positive orientation: E,N)\n *\n * NWMC (Normalized Webmercator Coordinates): represents the Webmercator *square*\n * with coordinates in the range +/-1. Results from dividing Webmercator coordinates\n * by WM_R. (positive orientation: E,N)\n *\n * TC (Tile coordinates): integers in [0, 2^Z) for zoom level Z. Example: the tile 0/0/0 (zoom, x, y) is the root tile.\n * (positive orientation: E,S)\n *\n * An RSys's rectangle (its bounds) is the area covered by the local coordinates in\n * the range +/-1.\n *\n * When an RSys external coordinate system is WM or NWMC, we can compute:\n * * Minimum zoom level for which tiles are no larger than the RSys rectangle:\n *   Math.ceil(Math.log2(1 / r.scale));\n * * Maximum zoom level for which tiles are no smaller than the rectangle:\n *   Math.floor(Math.log2(1 / r.scale));\n * (note that 1 / r.scale is the fraction of the World height that the local rectangle's height represents)\n *\n * We'll use the term World coordinates below for the *external* reference system\n * of an RSys (usually NWMC).\n */\n\n/* eslint no-unused-vars: [\"off\"] */\n\n/**\n * R coordinates to World\n * @param {RSys} r - ref. of the passed coordinates\n * @param {number} x - x coordinate in r\n * @param {number} y - y coordinate in r\n * @return {RPoint} World coordinates\n */\nfunction rToW (r, x, y) {\n    return { x: x * r.scale + r.center.x, y: y * r.scale + r.center.y };\n}\n\n/**\n * World coordinates to local RSys\n * @param {number} x - x W-coordinate\n * @param {number} y - y W-coordinate\n * @param {RSys} r - target ref. system\n * @return {RPoint} R coordinates\n */\nexport function wToR (x, y, r) {\n    return { x: (x - r.center.x) / r.scale, y: (y - r.center.y) / r.scale };\n}\n\n/**\n * RSys of a tile (mapping local tile coordinates in +/-1 to NWMC)\n * @param {number} x - TC x coordinate\n * @param {number} y - TC y coordinate\n * @param {number} z - Tile zoom level\n * @return {RSys}\n */\nfunction tileRsys (x, y, z) {\n    let max = Math.pow(2, z);\n    return { scale: 1 / max, center: { x: 2 * (x + 0.5) / max - 1, y: 1 - 2 * (y + 0.5) / max } };\n}\n\n/**\n * TC tiles that intersect the local rectangle of an RSys\n * (with the largest tile size no larger than the rectangle)\n * @param {RSys} rsys\n * @return {Array} - array of TC tiles {x, y, z}\n */\nexport function rTiles (zoom, bounds, viewportZoomToSourceZoom = Math.ceil) {\n    return wRectangleTiles(viewportZoomToSourceZoom(zoom), bounds);\n}\n\n/**\n * TC tiles of a given zoom level that intersect a W rectangle\n * @param {number} z\n * @param {Array} - rectangle extents [minx, miny, maxx, maxy]\n * @return {Array} - array of TC tiles {x, y, z}\n */\nfunction wRectangleTiles (z, wr) {\n    const [wMinx, wMiny, wMaxx, wMaxy] = wr;\n    const n = (1 << z); // for 0 <= z <= 30 equals Math.pow(2, z)\n\n    const clamp = x => Math.min(Math.max(x, 0), n - 1);\n    // compute tile coordinate ranges\n    const tMinx = clamp(Math.floor(n * (wMinx + 1) * 0.5));\n    const tMaxx = clamp(Math.ceil(n * (wMaxx + 1) * 0.5) - 1);\n    const tMiny = clamp(Math.floor(n * (1 - wMaxy) * 0.5));\n    const tMaxy = clamp(Math.ceil(n * (1 - wMiny) * 0.5) - 1);\n    let tiles = [];\n    for (let x = tMinx; x <= tMaxx; ++x) {\n        for (let y = tMiny; y <= tMaxy; ++y) {\n            tiles.push({ x: x, y: y, z: z });\n        }\n    }\n    return tiles;\n}\n\n/**\n * Get the Rsys of a tile where the Rsys's center is the tile center and the Rsys's scale is the tile extent.\n * @param {*} x\n * @param {*} y\n * @param {*} z\n * @returns {RSys}\n */\nexport function getRsysFromTile (x, y, z) {\n    return {\n        center: {\n            x: ((x + 0.5) / Math.pow(2, z)) * 2.0 - 1,\n            y: (1.0 - (y + 0.5) / Math.pow(2, z)) * 2.0 - 1.0\n        },\n        scale: 1 / Math.pow(2, z)\n    };\n}\n\nexport default { rTiles, getRsysFromTile, wToR };\n","import { decodeGeom } from './decoder';\nimport { computeAABB } from '../utils/geometry';\n\nexport default class DummyDataframe {\n    constructor ({ center, scale, geom, properties, type, active, size, metadata }) {\n        this.active = active;\n        this.center = center;\n        this.properties = properties;\n        this.scale = scale;\n        this.type = type;\n        this.decodedGeom = decodeGeom(type, geom);\n        this.numVertex = type === 'point'\n            ? size * 3\n            : this.decodedGeom.vertices.length / 2;\n        this.numFeatures = type === 'point' ? size : this.decodedGeom.breakpoints.length || this.numVertex;\n        this.propertyTex = [];\n        this.metadata = metadata;\n        this.propertyCount = 0;\n        this._aabb = computeAABB(geom, type);\n    }\n}\n","\n// The IDENTITY metadata contains zero properties\nexport const IDENTITY = {\n    properties: {}\n};\n\nexport default class Metadata {\n    constructor ({ properties, featureCount, sample, geomType, isAggregated, idProperty } = { properties: {} }) {\n        this.properties = properties;\n        this.featureCount = featureCount;\n        this.sample = sample;\n        this.geomType = geomType;\n        this.isAggregated = isAggregated;\n        this.idProperty = idProperty || 'cartodb_id';\n\n        this.categoryToID = new Map();\n        this.IDToCategory = new Map();\n        this.numCategories = 0;\n\n        Object.values(properties).map(property => {\n            property.categories = property.categories || [];\n            property.categories.map(category => this.categorizeString(property, category.name, true));\n        });\n\n        this.propertyKeys = Object.keys(this.properties);\n    }\n    categorizeString (propertyName, category, init = false) {\n        if (category === undefined) {\n            category = null;\n        }\n        if (this.categoryToID.has(category)) {\n            return this.categoryToID.get(category);\n        }\n        if (!init) {\n            this.properties[propertyName].categories.push({\n                name: category,\n                frequency: Number.NaN\n            });\n        }\n        this.categoryToID.set(category, this.numCategories);\n        this.IDToCategory.set(this.numCategories, category);\n        this.numCategories++;\n        return this.numCategories - 1;\n    }\n    propertyNames (propertyName) {\n        const prop = this.properties[propertyName];\n        if (prop.aggregations) {\n            return Object.keys(prop.aggregations).map(fn => prop.aggregations[fn]);\n        }\n        return [propertyName];\n    }\n}\n","import { getJoinNormal, getLineNormal, neg } from '../../utils/geometry';\n\n/**\n * Create a triangulated lineString: zero-sized, vertex-shader expanded triangle list\n * with `miter` joins. For angle < 60 joins are automatically adjusted to `bevel`.\n * https://github.com/CartoDB/carto-vl/wiki/Line-rendering\n */\nexport function addLineString (lineString, geomBuffer, index, isPolygon, skipCallback) {\n    let prevPoint, currentPoint, nextPoint;\n    let prevNormal, nextNormal;\n    let drawLine;\n\n    // We need at least two points\n    if (lineString.length >= 4) {\n        // Initialize the first two points\n        prevPoint = [lineString[0], lineString[1]];\n        currentPoint = [lineString[2], lineString[3]];\n        prevNormal = getLineNormal(prevPoint, currentPoint);\n\n        for (let i = 4; i <= lineString.length; i += 2) {\n            drawLine = !(skipCallback && skipCallback(i));\n\n            if (drawLine) {\n                // First triangle\n                geomBuffer.vertices[index] = prevPoint[0];\n                geomBuffer.normals[index++] = -prevNormal[0];\n                geomBuffer.vertices[index] = prevPoint[1];\n                geomBuffer.normals[index++] = -prevNormal[1];\n                geomBuffer.vertices[index] = prevPoint[0];\n                geomBuffer.normals[index++] = prevNormal[0];\n                geomBuffer.vertices[index] = prevPoint[1];\n                geomBuffer.normals[index++] = prevNormal[1];\n                geomBuffer.vertices[index] = currentPoint[0];\n                geomBuffer.normals[index++] = prevNormal[0];\n                geomBuffer.vertices[index] = currentPoint[1];\n                geomBuffer.normals[index++] = prevNormal[1];\n\n                // Second triangle\n                geomBuffer.vertices[index] = prevPoint[0];\n                geomBuffer.normals[index++] = -prevNormal[0];\n                geomBuffer.vertices[index] = prevPoint[1];\n                geomBuffer.normals[index++] = -prevNormal[1];\n                geomBuffer.vertices[index] = currentPoint[0];\n                geomBuffer.normals[index++] = prevNormal[0];\n                geomBuffer.vertices[index] = currentPoint[1];\n                geomBuffer.normals[index++] = prevNormal[1];\n                geomBuffer.vertices[index] = currentPoint[0];\n                geomBuffer.normals[index++] = -prevNormal[0];\n                geomBuffer.vertices[index] = currentPoint[1];\n                geomBuffer.normals[index++] = -prevNormal[1];\n            }\n\n            // If there is a next point, compute its properties\n            if (i <= lineString.length - 2) {\n                nextPoint = [lineString[i], lineString[i + 1]];\n            } else if (isPolygon) {\n                nextPoint = [lineString[2], lineString[3]];\n            }\n\n            if (nextPoint) {\n                nextNormal = getLineNormal(currentPoint, nextPoint);\n\n                if (drawLine) {\n                    // `turnLeft` indicates that the nextLine turns to the left\n                    // `joinNormal` contains the direction and size for the `miter` vertex\n                    //  If this is not defined means that the join must be `bevel`.\n                    let {turnLeft, joinNormal} = getJoinNormal(prevNormal, nextNormal);\n\n                    let leftNormal = turnLeft ? prevNormal : neg(nextNormal);\n                    let rightNormal = turnLeft ? nextNormal : neg(prevNormal);\n\n                    // Third triangle\n                    geomBuffer.vertices[index] = currentPoint[0];\n                    geomBuffer.normals[index++] = 0;\n                    geomBuffer.vertices[index] = currentPoint[1];\n                    // Mark vertex to be stroke in PolygonShader with the\n                    // non-zero value 1e-37, so it validates the expression\n                    // `normal != vec2(0.)` without affecting the vertex position.\n                    geomBuffer.normals[index++] = isPolygon ? 1e-37 : 0;\n                    geomBuffer.vertices[index] = currentPoint[0];\n                    geomBuffer.normals[index++] = leftNormal[0];\n                    geomBuffer.vertices[index] = currentPoint[1];\n                    geomBuffer.normals[index++] = leftNormal[1];\n                    geomBuffer.vertices[index] = currentPoint[0];\n                    geomBuffer.normals[index++] = rightNormal[0];\n                    geomBuffer.vertices[index] = currentPoint[1];\n                    geomBuffer.normals[index++] = rightNormal[1];\n\n                    if (joinNormal) {\n                        // Forth triangle\n                        geomBuffer.vertices[index] = currentPoint[0];\n                        geomBuffer.normals[index++] = joinNormal[0];\n                        geomBuffer.vertices[index] = currentPoint[1];\n                        geomBuffer.normals[index++] = joinNormal[1];\n                        geomBuffer.vertices[index] = currentPoint[0];\n                        geomBuffer.normals[index++] = rightNormal[0];\n                        geomBuffer.vertices[index] = currentPoint[1];\n                        geomBuffer.normals[index++] = rightNormal[1];\n                        geomBuffer.vertices[index] = currentPoint[0];\n                        geomBuffer.normals[index++] = leftNormal[0];\n                        geomBuffer.vertices[index] = currentPoint[1];\n                        geomBuffer.normals[index++] = leftNormal[1];\n                    }\n                }\n            }\n\n            // Update the variables for the next iteration\n            prevPoint = currentPoint;\n            currentPoint = nextPoint;\n            prevNormal = nextNormal;\n            nextPoint = null;\n        }\n    }\n    return index;\n}\n\n/**\n * Resize a Float32Array buffer in an efficient way\n */\nexport function resizeBuffer (oldBuffer, newSize) {\n    const newBuffer = new Float32Array(newSize);\n    newBuffer.set(oldBuffer);\n    return newBuffer;\n}\n","import { decodePoint } from './pointDecoder';\nimport { decodeLine } from './lineDecoder';\nimport { decodePolygon } from './polygonDecoder';\n\nexport function decodeGeom (geomType, geom) {\n    switch (geomType) {\n        case 'point':\n            return decodePoint(geom);\n        case 'line':\n            return decodeLine(geom);\n        case 'polygon':\n            return decodePolygon(geom);\n        default:\n            throw new Error(`Unimplemented geometry type: '${geomType}'`);\n    }\n}\n","import { addLineString, resizeBuffer } from './common';\n\n// If the geometry type is 'line' it will generate the appropriate zero-sized, vertex-shader expanded triangle list with `miter` and `bevel` joins.\n// The geom will be an array of coordinates in this case\n\nconst STATIC_INITIAL_BUFFER_SIZE = 1024 * 1024; // 4 MB\nconst MAX_VERTICES_COORDINATES_PER_SEGMENT = 24;\n\nlet index = 0;\nlet geomBuffer = {\n    vertices: new Float32Array(STATIC_INITIAL_BUFFER_SIZE),\n    normals: new Float32Array(STATIC_INITIAL_BUFFER_SIZE)\n};\n\nexport function decodeLine (geometry) {\n    let breakpoints = []; // Array of indices (to vertexArray) that separate each feature\n    let featureIDToVertexIndex = new Map();\n\n    index = 0;\n    for (let i = 0; i < geometry.length; i++) {\n        const feature = geometry[i];\n        for (let j = 0; j < feature.length; j++) {\n            // Increase buffers size if required\n            resizeBuffers(MAX_VERTICES_COORDINATES_PER_SEGMENT * feature[j].length);\n\n            // Add line string\n            index = addLineString(feature[j], geomBuffer, index);\n        }\n\n        featureIDToVertexIndex.set(breakpoints.length, breakpoints.length === 0\n            ? { start: 0, end: index }\n            : { start: featureIDToVertexIndex.get(breakpoints.length - 1).end, end: index });\n\n        breakpoints.push(index);\n    }\n\n    const verticesArrayBuffer = new ArrayBuffer(4 * index);\n    const normalsArrayBuffer = new ArrayBuffer(4 * index);\n    const vertices = new Float32Array(verticesArrayBuffer);\n    const normals = new Float32Array(normalsArrayBuffer);\n    for (let i = 0; i < index; i++) {\n        vertices[i] = geomBuffer.vertices[i];\n        normals[i] = geomBuffer.normals[i];\n    }\n    return {\n        vertices,\n        normals,\n        verticesArrayBuffer,\n        normalsArrayBuffer,\n        featureIDToVertexIndex,\n        breakpoints\n    };\n}\n\n// Resize buffers as needed if `additionalSize` floats overflow the current buffers.\nfunction resizeBuffers (additionalSize) {\n    const minimumNeededSize = index + additionalSize;\n    if (minimumNeededSize > geomBuffer.vertices.length) {\n        const newSize = 2 * minimumNeededSize;\n        geomBuffer.vertices = resizeBuffer(geomBuffer.vertices, newSize);\n        geomBuffer.normals = resizeBuffer(geomBuffer.normals, newSize);\n    }\n}\n","// If the geometry type is 'point' it will pass trough the geom (the vertex array)\n\nexport function decodePoint (verticesArrayBuffer) {\n    return {\n        verticesArrayBuffer: verticesArrayBuffer,\n        vertices: new Float32Array(verticesArrayBuffer),\n        breakpoints: []\n    };\n}\n","import * as earcut from 'earcut';\nimport { addLineString, resizeBuffer } from './common';\n\n// If the geometry type is 'polygon' it will triangulate the polygon list (geom)\n// geom will be a list of polygons in which each polygon will have a flat array of vertices and a list of holes indices\n// Example:\n/*   let geom = [{\n       flat: [\n         0.,0., 1.,0., 1.,1., 0.,1., 0.,0, //A square\n         0.25,0.25, 0.75,0.25, 0.75,0.75, 0.25,0.75, 0.25,0.25//A small square\n       ]\n       holes: [5]\n     }]\n*/\n\nconst STATIC_INITIAL_BUFFER_SIZE = 1024 * 1024 * 2; // 8 MB\nconst VERTEX_COORDINATES_PER_TRIANGLE = 2;\nconst MAX_VERTICES_COORDINATES_PER_SEGMENT = 24;\n\nlet index = 0;\nlet geomBuffer = {\n    vertices: new Float32Array(STATIC_INITIAL_BUFFER_SIZE),\n    normals: new Float32Array(STATIC_INITIAL_BUFFER_SIZE)\n};\n\nexport function decodePolygon (geometry) {\n    let breakpoints = []; // Array of indices (to vertexArray) that separate each feature\n    let featureIDToVertexIndex = new Map();\n\n    index = 0;\n    for (let i = 0; i < geometry.length; i++) {\n        const feature = geometry[i];\n        for (let j = 0; j < feature.length; j++) {\n            const polygon = feature[j];\n            const triangles = earcut(polygon.flat, polygon.holes);\n\n            // Increase buffers size if required\n            resizeBuffers(VERTEX_COORDINATES_PER_TRIANGLE * triangles.length +\n                          MAX_VERTICES_COORDINATES_PER_SEGMENT * polygon.flat.length);\n\n            // Add polygon\n            for (let k = 0; k < triangles.length; k++) {\n                addVertex(polygon.flat, 2 * triangles[k]);\n            }\n\n            // Add polygon stroke\n            index = addLineString(polygon.flat, geomBuffer, index, true, (pointIndex) => {\n                // Skip adding the line which connects two rings OR is clipped\n                return polygon.holes.includes((pointIndex - 2) / 2) || isClipped(polygon, pointIndex - 4, pointIndex - 2);\n            });\n        }\n\n        featureIDToVertexIndex.set(breakpoints.length, breakpoints.length === 0\n            ? { start: 0, end: index }\n            : { start: featureIDToVertexIndex.get(breakpoints.length - 1).end, end: index });\n\n        breakpoints.push(index);\n    }\n\n    const verticesArrayBuffer = new ArrayBuffer(4 * index);\n    const normalsArrayBuffer = new ArrayBuffer(4 * index);\n    const vertices = new Float32Array(verticesArrayBuffer);\n    const normals = new Float32Array(normalsArrayBuffer);\n    for (let i = 0; i < index; i++) {\n        vertices[i] = geomBuffer.vertices[i];\n        normals[i] = geomBuffer.normals[i];\n    }\n    return {\n        vertices,\n        normals,\n        verticesArrayBuffer,\n        normalsArrayBuffer,\n        featureIDToVertexIndex,\n        breakpoints\n    };\n}\n\n// Resize buffers as needed if `additionalSize` floats overflow the current buffers\nfunction resizeBuffers (additionalSize) {\n    const minimumNeededSize = index + additionalSize;\n    if (minimumNeededSize > geomBuffer.vertices.length) {\n        const newSize = 2 * minimumNeededSize;\n        geomBuffer.vertices = resizeBuffer(geomBuffer.vertices, newSize);\n        geomBuffer.normals = resizeBuffer(geomBuffer.normals, newSize);\n    }\n}\n\n// Add vertex in triangles.\nfunction addVertex (array, vertexIndex) {\n    geomBuffer.vertices[index] = array[vertexIndex];\n    geomBuffer.normals[index++] = 0;\n    geomBuffer.vertices[index] = array[vertexIndex + 1];\n    geomBuffer.normals[index++] = 0;\n}\n\nfunction isClipped (polygon, i, j) {\n    if (polygon.clipped.includes(i) && polygon.clipped.includes(j)) {\n        if (polygon.clippedType[polygon.clipped.indexOf(i)] &\n            polygon.clippedType[polygon.clipped.indexOf(j)]) {\n            return true;\n        }\n    }\n    return false;\n}\n","\nexport const IDENTITY = {};\n\n/*\nconst mns = {\n    price:  [{type: 'unaggregated'}],\n    amount: [{type: 'aggregated', op: 'avg'}, {type: 'aggregated', op: 'max'}}]\n};\n\n*/\n\nexport function union (a, b) {\n    const result = {};\n    const propertyNames = new Set(Object.keys(a).concat(Object.keys(b)));\n    propertyNames.forEach(propertyName => {\n        const aUsages = a[propertyName] || [];\n        const bUsages = b[propertyName] || [];\n        const combinedUsage = [...aUsages, ...bUsages];\n        result[propertyName] = combinedUsage;\n    });\n    return result;\n}\n\nexport function equals (a, b) {\n    if (!a || !b) {\n        return false;\n    }\n    return JSON.stringify(simplify(a)) === JSON.stringify(simplify(b));\n}\n\nfunction simplify (MNS) {\n    const result = {};\n    const propertyNames = Object.keys(MNS).sort();\n    propertyNames.forEach(propertyName => {\n        // Stringify and Set to remove duplicates\n        let usage = [...new Set(MNS[propertyName].map(u => JSON.stringify(u)))];\n        usage.sort();\n        usage = usage.map(u => JSON.parse(u));\n        result[propertyName] = usage;\n    });\n    return result;\n}\n\nconst AGG_PREFIX = '_cdb_agg_';\nconst AGG_PATTERN = new RegExp('^' + AGG_PREFIX + '[a-zA-Z0-9]+_');\n\nexport const CLUSTER_FEATURE_COUNT = '_cdb_feature_count';\n\n// column information functions\nexport const column = {\n    isAggregated: function isAggregated (name) {\n        return name.startsWith(AGG_PREFIX);\n    },\n    getBase: function getBase (name) {\n        return name.replace(AGG_PATTERN, '');\n    },\n    getAggFN: function getAggFN (name) {\n        let s = name.substr(AGG_PREFIX.length);\n        return s.substr(0, s.indexOf('_'));\n    },\n    aggColumn (name, aggFN) {\n        return `${AGG_PREFIX}${aggFN}_${name}`;\n    }\n};\n\nexport default { column, equals, union, IDENTITY, simplify };\n","import { VectorTile } from '@mapbox/vector-tile';\nimport * as Protobuf from 'pbf';\nimport * as rsys from '../client/rsys';\nimport { decodeLines, decodePolygons } from '../client/mvt/feature-decoder';\nimport Metadata from '../renderer/Metadata';\nimport DummyDataframe from '../renderer/DummyDataframe';\n\n// TODO import correctly\nconst RTT_WIDTH = 1024;\n\n// Constants for '@mapbox/vector-tile' geometry types, from https://github.com/mapbox/vector-tile-js/blob/v1.3.0/lib/vectortilefeature.js#L39\nconst mvtDecoderGeomTypes = { point: 1, line: 2, polygon: 3 };\n\nconst geometryTypes = {\n    UNKNOWN: 'unknown',\n    POINT: 'point',\n    LINE: 'line',\n    POLYGON: 'polygon'\n};\n\nconst MVT_TO_CARTO_TYPES = {\n    1: geometryTypes.POINT,\n    2: geometryTypes.LINE,\n    3: geometryTypes.POLYGON\n};\n\nexport class MVTWorker {\n    // Worker API\n    onmessage (event) {\n        this.processEvent(event).then(message => {\n            const transferables = [];\n            if (!message.dataframe.empty) {\n                transferables.push(this._propertiesArrayBuffer);\n                transferables.push(message.dataframe.decodedGeom.verticesArrayBuffer);\n                if (message.dataframe.decodedGeom.normalsArrayBuffer) {\n                    transferables.push(message.dataframe.decodedGeom.normalsArrayBuffer);\n                }\n            }\n            postMessage(message, transferables);\n        });\n    }\n    async processEvent (event) {\n        const params = event.data;\n        if (params.metadata) {\n            Object.setPrototypeOf(params.metadata, Metadata.prototype);\n            this.metadata = params.metadata;\n        }\n        const dataframe = await this._requestDataframe(params.x, params.y, params.z, params.url, params.layerID, this.metadata);\n        return {\n            mID: params.mID,\n            dataframe\n        };\n    }\n\n    async _requestDataframe (x, y, z, url, layerID, metadata) {\n        const response = await fetch(url);\n        const dataframe = await this.urlToDataframeTransformer(response, x, y, z, layerID, metadata);\n        return dataframe;\n    }\n\n    async urlToDataframeTransformer (response, x, y, z, layerID, metadata) {\n        const MVT_EXTENT = 4096;\n        const arrayBuffer = await response.arrayBuffer();\n        if (arrayBuffer.byteLength === 0 || response === 'null') {\n            return { empty: true };\n        }\n        const tile = new VectorTile(new Protobuf(arrayBuffer));\n\n        if (Object.keys(tile.layers).length > 1 && !layerID) {\n            throw new Error(`LayerID parameter wasn't specified and the MVT tile contains multiple layers: ${JSON.stringify(Object.keys(tile.layers))}`);\n        }\n\n        const mvtLayer = tile.layers[layerID || Object.keys(tile.layers)[0]]; // FIXME this!!!\n\n        if (!mvtLayer) {\n            return { empty: true };\n        }\n\n        const { geometries, properties, numFeatures } = this._decodeMVTLayer(mvtLayer, metadata, MVT_EXTENT);\n        const rs = rsys.getRsysFromTile(x, y, z);\n        const dataframe = this._generateDataFrame(rs, geometries, properties, numFeatures, metadata.geomType, metadata);\n\n        return dataframe;\n    }\n\n    _decodeMVTLayer (mvtLayer, metadata, mvtExtent) {\n        if (!mvtLayer.length) {\n            return { properties: [], geometries: {}, numFeatures: 0 };\n        }\n        if (!metadata.geomType) {\n            metadata.geomType = this._autoDiscoverType(mvtLayer);\n        }\n        switch (metadata.geomType) {\n            case geometryTypes.POINT:\n                const arrayBuffer = new ArrayBuffer(mvtLayer.length * 2 * 3 * 4);// SIZEOF\n                return this._decode(mvtLayer, metadata, mvtExtent, arrayBuffer);\n            case geometryTypes.LINE:\n                return this._decode(mvtLayer, metadata, mvtExtent, [], decodeLines);\n            case geometryTypes.POLYGON:\n                return this._decode(mvtLayer, metadata, mvtExtent, [], decodePolygons);\n            default:\n                throw new Error('MVT: invalid geometry type');\n        }\n    }\n\n    _autoDiscoverType (mvtLayer) {\n        const type = mvtLayer.feature(0).type;\n        switch (type) {\n            case mvtDecoderGeomTypes.point:\n                return geometryTypes.POINT;\n            case mvtDecoderGeomTypes.line:\n                return geometryTypes.LINE;\n            case mvtDecoderGeomTypes.polygon:\n                return geometryTypes.POLYGON;\n            default:\n                throw new Error('MVT: invalid geometry type');\n        }\n    }\n\n    _decode (mvtLayer, metadata, mvtExtent, geometries, decodeFn) {\n        let numFeatures = 0;\n        let pointGeometries;\n        if (geometries) {\n            pointGeometries = new Float32Array(geometries);\n        }\n        const { properties, propertyNames } = this._initializePropertyArrays(metadata, mvtLayer.length);\n        for (let i = 0; i < mvtLayer.length; i++) {\n            const f = mvtLayer.feature(i);\n            this._checkType(f, metadata.geomType);\n            const geom = f.loadGeometry();\n            if (decodeFn) {\n                const decodedPolygons = decodeFn(geom, mvtExtent);\n                geometries.push(decodedPolygons);\n            } else {\n                // TODO refactor\n                const x = 2 * (geom[0][0].x) / mvtExtent - 1.0;\n                const y = 2 * (1.0 - (geom[0][0].y) / mvtExtent) - 1.0;\n                // Tiles may contain points in the border;\n                // we'll avoid here duplicated points between tiles by excluding the 1-edge\n                if (x < -1 || x >= 1 || y < -1 || y >= 1) {\n                    continue;\n                }\n                pointGeometries[6 * numFeatures + 0] = x;\n                pointGeometries[6 * numFeatures + 1] = y;\n                pointGeometries[6 * numFeatures + 2] = x;\n                pointGeometries[6 * numFeatures + 3] = y;\n                pointGeometries[6 * numFeatures + 4] = x;\n                pointGeometries[6 * numFeatures + 5] = y;\n            }\n            if (f.properties[metadata.idProperty] === undefined) {\n                throw new Error(`MVT feature with undefined idProperty '${metadata.idProperty}'`);\n            }\n            this._decodeProperties(metadata, propertyNames, properties, f, numFeatures);\n            numFeatures++;\n        }\n\n        return { properties, geometries, numFeatures };\n    }\n\n    // Currently only mvtLayers with the same type in every feature are supported\n    _checkType (feature, expected) {\n        const type = feature.type;\n        const actual = MVT_TO_CARTO_TYPES[type];\n        if (actual !== expected) {\n            throw new Error(`MVT: mixed geometry types in the same layer. Layer has type: ${expected} but feature was ${actual}`);\n        }\n    }\n\n    _initializePropertyArrays (metadata, length) {\n        const propertyNames = this._getPropertyNamesFrom(metadata);\n        const properties = this._getPropertiesFor(propertyNames, length);\n        return { propertyNames, properties };\n    }\n\n    _getPropertyNamesFrom (metadata) {\n        const propertyNames = [];\n        for (let i = 0; i < metadata.propertyKeys.length; i++) {\n            const propertyName = metadata.propertyKeys[i];\n            if (metadata.properties[propertyName].type === 'geometry') {\n                continue;\n            }\n            propertyNames.push(...metadata.propertyNames(propertyName));\n        }\n        return propertyNames;\n    }\n\n    _getPropertiesFor (propertyNames, length) {\n        const properties = {};\n        const size = Math.ceil(length / RTT_WIDTH) * RTT_WIDTH;\n\n        const arrayBuffer = new ArrayBuffer(4 * size * propertyNames.length);\n        this._propertiesArrayBuffer = arrayBuffer;\n        for (let i = 0; i < propertyNames.length; i++) {\n            const propertyName = propertyNames[i];\n            properties[propertyName] = new Float32Array(arrayBuffer, i * 4 * size, size);\n        }\n\n        return properties;\n    }\n\n    _decodeProperties (metadata, propertyNames, properties, feature, i) {\n        const length = propertyNames.length;\n        for (let j = 0; j < length; j++) {\n            const propertyName = propertyNames[j];\n            const propertyValue = feature.properties[propertyName];\n            properties[propertyName][i] = this.decodeProperty(metadata, propertyName, propertyValue);\n        }\n    }\n\n    decodeProperty (metadata, propertyName, propertyValue) {\n        if (typeof propertyValue === 'string') {\n            if (metadata.properties[propertyName].type !== 'category') {\n                throw new Error(`MVT decoding error. Metadata property '${propertyName}' is of type '${metadata.properties[propertyName].type}' but the MVT tile contained a feature property of type string: '${propertyValue}'`);\n            }\n            return metadata.categorizeString(propertyName, propertyValue);\n        } else if (typeof propertyValue === 'number') {\n            if (metadata.properties[propertyName].type !== 'number') {\n                throw new Error(`MVT decoding error. Metadata property '${propertyName}' is of type '${metadata.properties[propertyName].type}' but the MVT tile contained a feature property of type number: '${propertyValue}'`);\n            }\n            return propertyValue;\n        } else if (propertyValue === null || propertyValue === undefined) {\n            return Number.NaN;\n        } else {\n            throw new Error(`MVT decoding error. Feature property value of type '${typeof propertyValue}' cannot be decoded.`);\n        }\n    }\n\n    _generateDataFrame (rs, geometry, properties, size, type, metadata) {\n        return new DummyDataframe({\n            active: false,\n            center: rs.center,\n            geom: geometry,\n            properties: properties,\n            scale: rs.scale,\n            size: size,\n            type: type,\n            metadata\n        });\n    }\n}\n","import { MVTWorker } from './MVTWorker';\nimport { WindshaftWorker } from '../client/WindshaftWorker';\n\n// This file publishes a Web Worker onmessage function that will redirect incoming messages\n// based on an ID (`workerName`) defined by the message sender\n// to each different Worker implementation\n\nconst workers = {\n    MVT: new MVTWorker(),\n    windshaft: new WindshaftWorker()\n};\n\nonmessage = function (event) {\n    return workers[event.data.workerName].onmessage(event);\n};\n","// If AB intersects CD => return intersection point\n// Intersection method from Real Time Rendering, Third Edition, page 780\nexport function intersect (a, b, c, d) {\n    const o1 = a;\n    const o2 = c;\n    const d1 = sub(b, a);\n    const d2 = sub(d, c);\n    const d1t = perpendicular(d1);\n    const d2t = perpendicular(d2);\n\n    const s = dot(sub(o2, o1), d2t) / dot(d1, d2t);\n    const t = dot(sub(o1, o2), d1t) / dot(d2, d1t);\n\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n        return [o1[0] + s * d1[0], o1[1] + s * d1[1]];\n    }\n}\n\nexport function sub ([ax, ay], [bx, by]) {\n    return ([ax - bx, ay - by]);\n}\n\nexport function dot ([ax, ay], [bx, by]) {\n    return (ax * bx + ay * by);\n}\n\nexport function perpendicular ([x, y]) {\n    return [-y, x];\n}\n\n/**\n * Compute the normal of a line AB.\n * By definition it is the unitary vector from B to A, rotated +90 degrees counter-clockwise\n */\nexport function getLineNormal (a, b) {\n    const u = normalize(a[0] - b[0], a[1] - b[1]);\n    return [-u[1], u[0]];\n}\n\n/**\n * Compute the normal of the join from the lines' normals.\n * By definition this is the sum of the unitary vectors `u` (from B to A) and `v` (from B to C)\n * multiplied by a factor of `1/sin(theta)` to reach the intersection of the wide lines.\n * Theta is the angle between the vectors `v` and `u`. But instead of computing the angle,\n * the `sin(theta)` (with sign) is obtained directly from the vectorial product of `v` and `u`\n */\nexport function getJoinNormal (prevNormal, nextNormal) {\n    const u = [prevNormal[1], -prevNormal[0]];\n    const v = [-nextNormal[1], nextNormal[0]];\n    const sin = v[0] * u[1] - v[1] * u[0];\n    const cos = v[0] * u[0] + v[1] * u[1];\n    const factor = Math.abs(sin);\n    const miterJoin = !(factor < 0.866 && cos > 0.5); // 60 deg\n    return {\n        turnLeft: sin > 0,\n        joinNormal: miterJoin && neg([\n            (u[0] + v[0]) / factor,\n            (u[1] + v[1]) / factor\n        ])\n    };\n}\n\n/**\n * Return the negative of the provided vector\n */\nexport function neg (v) {\n    return [-v[0], -v[1]];\n}\n\n/**\n * Return the vector scaled to length 1\n */\nfunction normalize (x, y) {\n    const s = Math.hypot(x, y);\n    return [x / s, y / s];\n}\n\n// Returns true if p is inside the triangle or on a triangle's edge, false otherwise\n// Parameters in {x: 0, y:0} form\nexport function pointInTriangle (p, v1, v2, v3) {\n    // https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle\n    // contains an explanation of both this algorithm and one based on barycentric coordinates,\n    // which could be faster, but, nevertheless, it is quite similar in terms of required arithmetic operations\n\n    if (equalPoints(v1, v2) || equalPoints(v2, v3) || equalPoints(v3, v1)) {\n        // Avoid zero area triangle\n        return false;\n    }\n\n    // A point is inside a triangle or in one of the triangles edges\n    // if the point is in the three half-plane defined by the 3 edges\n    const b1 = halfPlaneSign(p, v1, v2) < 0;\n    const b2 = halfPlaneSign(p, v2, v3) < 0;\n    const b3 = halfPlaneSign(p, v3, v1) < 0;\n\n    return (b1 === b2) && (b2 === b3);\n}\n\n// Tests if a point `p` is in the half plane defined by the line with points `a` and `b`\n// Returns a negative number if the result is INSIDE, returns 0 if the result is ON_LINE,\n// returns >0 if the point is OUTSIDE\n// Parameters in {x: 0, y:0} form\nexport function halfPlaneSign (p, a, b) {\n    // We use the cross product of `PB x AB` to get `sin(angle(PB, AB))`\n    // The result's sign is the half plane test result\n    return (p.x - b.x) * (a.y - b.y) - (a.x - b.x) * (p.y - b.y);\n}\n\nexport function equalPoints (a, b) {\n    return (a.x === b.x) && (a.y === b.y);\n}\n\nexport function pointInCircle (p, center, scale) {\n    const diff = {\n        x: p.x - center.x,\n        y: p.y - center.y\n    };\n    const lengthSquared = diff.x * diff.x + diff.y * diff.y;\n    return lengthSquared <= scale * scale;\n}\n\nexport function pointInRectangle (point, bbox) {\n    if (bbox === null) {\n        return false;\n    }\n    const p = {\n        x: point.x.toFixed(2),\n        y: point.y.toFixed(2)\n    };\n\n    return ((bbox.minx <= p.x) && (p.x <= bbox.maxx) && (bbox.miny <= p.y) && (p.y <= bbox.maxy));\n}\n\nexport function computeAABB (geometry, type) {\n    switch (type) {\n        case 'point':\n            return [];\n        case 'line':\n        case 'polygon':\n            const aabbList = [];\n\n            for (let i = 0; i < geometry.length; i++) {\n                const feature = geometry[i];\n\n                let aabb = {\n                    minx: Number.POSITIVE_INFINITY,\n                    miny: Number.POSITIVE_INFINITY,\n                    maxx: Number.NEGATIVE_INFINITY,\n                    maxy: Number.NEGATIVE_INFINITY\n                };\n\n                for (let j = 0; j < feature.length; j++) {\n                    aabb = _updateAABBForGeometry(feature[j], aabb, type);\n                }\n\n                if (aabb.minx === Number.POSITIVE_INFINITY) {\n                    aabb = null;\n                }\n\n                aabbList.push(aabb);\n            }\n\n            return aabbList;\n    }\n}\n\nfunction _updateAABBForGeometry (feature, aabb, geometryType) {\n    switch (geometryType) {\n        case 'line':\n            return _updateAABBLine(feature, aabb);\n        case 'polygon':\n            return _updateAABBPolygon(feature, aabb);\n    }\n}\n\nfunction _updateAABBLine (line, aabb) {\n    const vertices = line;\n    const numVertices = line.length;\n\n    for (let i = 0; i < numVertices; i += 2) {\n        aabb.minx = Math.min(aabb.minx, vertices[i + 0]);\n        aabb.miny = Math.min(aabb.miny, vertices[i + 1]);\n        aabb.maxx = Math.max(aabb.maxx, vertices[i + 0]);\n        aabb.maxy = Math.max(aabb.maxy, vertices[i + 1]);\n    }\n\n    return aabb;\n}\n\nfunction _updateAABBPolygon (polygon, aabb) {\n    const [vertices, numVertices] = [polygon.flat, polygon.holes[0] || polygon.flat.length / 2];\n\n    for (let i = 0; i < numVertices; i++) {\n        aabb.minx = Math.min(aabb.minx, vertices[2 * i + 0]);\n        aabb.miny = Math.min(aabb.miny, vertices[2 * i + 1]);\n        aabb.maxx = Math.max(aabb.maxx, vertices[2 * i + 0]);\n        aabb.maxy = Math.max(aabb.maxy, vertices[2 * i + 1]);\n    }\n\n    return aabb;\n}\n\nexport default {\n    intersect,\n    sub,\n    dot,\n    perpendicular,\n    getLineNormal,\n    getJoinNormal,\n    neg,\n    halfPlaneSign,\n    pointInTriangle,\n    equalPoints,\n    pointInCircle,\n    pointInRectangle\n};\n"],"sourceRoot":""}