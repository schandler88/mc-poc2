'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const core = require('./core-894cddb9.js');
const icons = require('./icons-2d2d2d13.js');
const index = require('./index-4a52f739.js');
const constants = require('./constants-e65c6c4c.js');

function sameData(first, second) {
    if (first.length !== second.length) {
        return false;
    }
    for (let i = 0; i < first.length; i++) {
        if (first[i].start !== second[i].start ||
            first[i].end !== second[i].end ||
            first[i].value !== second[i].value ||
            first[i].color !== second[i].color) {
            return false;
        }
    }
    return true;
}

const SCRUBBER_SIZE = 6;
const TimeSeriesWidget = class {
    constructor(hostRef) {
        core.registerInstance(this, hostRef);
        /**
         * Toggles displaying title and description
         *
         * @type {boolean}
         * @memberof HistogramWidget
         */
        this.showHeader = true;
        /**
         * Disables selection brushes and events for the widget
         *
         * @type {boolean}
         * @memberof HistogramWidget
         */
        this.disableInteractivity = false;
        /**
         * Histogram data to be displayed
         *
         * @type {HistogramData[]}
         * @memberof HistogramWidget
         */
        this.data = [];
        /**
         * Histogram data to be displayed
         *
         * @type {HistogramData[]}
         * @memberof HistogramWidget
         */
        this.backgroundData = [];
        /**
         * Override color for the histogram bars
         *
         * @type {string}
         * @memberof HistogramWidget
         */
        this.color = constants.DEFAULT_BAR_COLOR;
        /**
         * Override color for the selected histogram bars
         *
         * @type {string}
         * @memberof HistogramWidget
         */
        this.unselectedColor = constants.DEFAULT_BACKGROUND_BAR_COLOR;
        /**
         * Use this attribute to put the widget in "loading mode".
         * When loading mode is active, a spinner will be shown and the data will be hidden.
         */
        this.isLoading = false;
        /**
         * Use this widget to put the widget in "error mode".
         * When error mode is active. The header will display the given text.
         * And the body will be display the errorDescription instead any data.
         */
        this.error = '';
        /**
         * Extended error description, only shown when error is present
         */
        this.errorDescription = '';
        /**
         * Message shown in header when no data is available
         */
        this.noDataHeaderMessage = 'NO DATA AVAILABLE';
        /**
         * Message shown in body when no data is available
         */
        this.noDataBodyMessage = 'There is no data to display.';
        /**
         * Use this attribute to decide if the widget should be rerendered on window resize.
         * Defaults to true.
         */
        this.responsive = true;
        /**
         * This attribute is the percentage of progress elapsed on an animation.
         */
        this.progress = 0;
        /**
         * Whether the animation is playing or not.
         */
        this.playing = false;
        /**
         * Whether it should have animated properties or not. Disabling this makes this look
         * like a histogra widget with time capabilities
         */
        this.animated = false;
        /**
         * This string will be parsed by d3-time-format (https://github.com/d3/d3-time-format)
         * and will be used to format the graph's x-axis
         */
        this.timeFormat = constants.AUTO_FORMAT;
        /**
         * Text rendered inside the clear selection button
         */
        this.clearText = 'Clear selection';
        /**
         * This prop lets you provide the range of the y-axis so it's not automatically calculated with
         * data or backgroundData. It always starts at 0, you can provide the top value.
         *
         * @memberof HistogramWidget
         */
        this.range = null;
        /**
         * This lets you disable the animations for the bars when showing / updating the data
         *
         * @type {boolean}
         * @memberof HistogramWidget
         */
        this.disableAnimation = false;
        /**
         * This prop is a proxy to some d3-axis options for the X Axis
         *
         * @type {AxisOptions}
         * @memberof TimeSeriesWidget
         */
        this.xAxisOptions = {};
        /**
         * This prop is a proxy to some d3-axis options for the Y Axis
         *
         * @type {AxisOptions}
         * @memberof TimeSeriesWidget
         */
        this.yAxisOptions = {};
        this.axisFormatter = this.axisFormatter.bind(this);
        this.play = core.createEvent(this, "play", 7);
        this.pause = core.createEvent(this, "pause", 7);
        this.selectionChanged = core.createEvent(this, "selectionChanged", 7);
        this.seek = core.createEvent(this, "seek", 7);
    }
    onDataChanged(newData, oldData) {
        if (sameData(newData, oldData)) {
            return;
        }
        else {
            this.timeFormat = this.timeFormat === constants.AUTO_FORMAT
                ? typeof this.data[0].start === 'number' ? constants.DEFAULT_NUMBER_FORMAT : constants.DEFAULT_DATE_FORMAT
                : this.timeFormat;
        }
    }
    onBackgroundDataChanged(newData) {
        this._backgroundData = newData;
    }
    onProgressChanged() {
        this._render();
    }
    onTimeFormatChanged(newFormat) {
        this._formatter = index.timeFormat(newFormat);
        if (this.histogram) {
            this.histogram.forceUpdate();
        }
    }
    onTimeFormatLocaleChanged(newLocale) {
        try {
            index.defaultLocale(newLocale);
            if (this.timeFormat) {
                this.onTimeFormatChanged(this.timeFormat);
            }
        }
        catch (e) {
            throw new Error('Invalid time format.');
        }
    }
    /**
     * Proxy to as-histogram-widget defaultFormatter()
     *
     * @memberof TimeSeriesWidget
     */
    async defaultFormatter(data) {
        return this.histogram.defaultFormatter(data);
    }
    /**
     * Proxy to as-histogram-widget getSelection()
     *
     * @returns {number[]|string[]}
     * @memberof TimeSeriesWidget
     */
    async getSelection() {
        return this.histogram.getSelection();
    }
    /**
     * Proxy to as-histogram-widget setSelection()
     *
     * @param {number[] | null} values
     * @memberof TimeSeriesWidget
     */
    async setSelection(values) {
        this.histogram.setSelection(values);
    }
    /**
     * Proxy to as-histogram-widget clearSelection()
     *
     * @memberof TimeSeriesWidget
     */
    async clearSelection() {
        this.histogram.clearSelection();
    }
    /**
     * Proxy to as-histogram-widget xFormatter method
     * @param value
     */
    async xFormatter(value) {
        return this.histogram.xFormatter(value);
    }
    async componentWillLoad() {
        this.onDataChanged(this.data, []);
        this.onBackgroundDataChanged(this.backgroundData);
    }
    async componentDidLoad() {
        if (this.timeFormatLocale) {
            index.defaultLocale(this.timeFormatLocale);
        }
        this._formatter = index.timeFormat(this.timeFormat);
        this.histogram.addEventListener('selectionInput', (evt) => {
            if (evt.detail === null) {
                this._selection = null;
            }
            else {
                this._selection = evt.detail.selection;
            }
            this._render();
        });
        this.histogram.addEventListener('selectionChanged', (evt) => {
            evt.stopPropagation();
            if (evt.detail === null) {
                this.selectionChanged.emit(null);
                return;
            }
            // We have to coerce to Array<number | Date> because it can also be string[] for categorical histograms
            const selectedDates = evt.detail.selection;
            this.selectionChanged.emit(selectedDates);
            this._render();
        });
        this.histogram.addEventListener('drawParametersChanged', (evt) => {
            this._renderOptions = evt.detail;
            this._render();
        });
        this._selection = await this.histogram.getSelection();
    }
    render() {
        const classes = {
            'as-time-series--animated': this.animated
        };
        return core.h(core.Host, { class: classes }, this._renderButton(), core.h("as-histogram-widget", { ref: (ref) => { this.histogram = ref; }, heading: this.heading, description: this.description, showHeader: this.showHeader, showClear: this.showClear, disableInteractivity: this.disableInteractivity, data: this.data, backgroundData: this._backgroundData, color: this.color, unselectedColor: this.unselectedColor, colorRange: this.colorRange, axisFormatter: this.axisFormatter, tooltipFormatter: this.tooltipFormatter || this._tooltipFormatter.bind(this), xLabel: this.xLabel, yLabel: this.yLabel, isLoading: this.isLoading, error: this.error, errorDescription: this.errorDescription, noDataHeaderMessage: this.noDataHeaderMessage, noDataBodyMessage: this.noDataBodyMessage, responsive: this.responsive, clearText: this.clearText, range: this.range, disableAnimation: this.disableAnimation, xAxisOptions: this.xAxisOptions, yAxisOptions: this.yAxisOptions }));
    }
    axisFormatter(value) {
        return this._formatter(value);
    }
    _tooltipFormatter(data) {
        return [
            `${this.axisFormatter(data.start)} - ${this.axisFormatter(data.end)}`,
            `${data.value}`
        ];
    }
    _renderButton() {
        if (!this.animated) {
            return null;
        }
        const classes = {
            'as-time-series--play-button': true,
            'as-time-series--play-button-hidden': !this.data.length || this.isLoading || !!this.error,
            'as-time-series--play-button-x-label': !!this.xLabel
        };
        return core.h("div", { class: classes, onClick: this._playPauseClick.bind(this) }, icons.icon(this.playing ? 'PAUSE' : 'PLAY', 'var(--as--color--primary)', { width: '32px', height: '32px' }));
    }
    _playPauseClick() {
        this.playing ? this.pause.emit() : this.play.emit();
    }
    _render() {
        if (!this._renderOptions) {
            return;
        }
        const { container, height, width, padding, xScale, binsScale, handleWidth } = this._renderOptions;
        let timeSeries = container.select('.as-time-series--g');
        if (!this.animated) {
            if (!timeSeries.empty()) {
                timeSeries.remove();
            }
            return;
        }
        const { left } = container.node().getBoundingClientRect();
        const [X_PADDING, Y_PADDING] = padding;
        const progressScale = index.linear().domain([0, 100]);
        let trackOffset = 0;
        if (this._selection) {
            const selection = this._selection.map((e) => xScale(binsScale(e)));
            trackOffset = handleWidth / 2;
            progressScale.range([
                selection[0] + trackOffset + (SCRUBBER_SIZE / 2),
                selection[1] - trackOffset - (SCRUBBER_SIZE / 2)
            ]);
        }
        else {
            progressScale.range([0, width - X_PADDING]);
        }
        const xPos = progressScale(this.progress);
        container.on('click', () => {
            const evt = index.event;
            const pctX = Math.round(progressScale.invert(evt.clientX - left - X_PADDING + 8));
            // This probably means that there's a selection and you're clicking outside of it
            if (pctX > 100 || pctX < 0) {
                return;
            }
            this.seek.emit(pctX);
        });
        if (timeSeries.empty()) {
            timeSeries = container
                .append('g')
                .attr('class', 'as-time-series--g');
            timeSeries.append('line')
                .attr('class', 'as-time-series--preview')
                .attr('stroke-width', 4)
                .attr('stroke', 'gray')
                .attr('opacity', '0');
            timeSeries.append('line')
                .attr('class', 'as-time-series--line')
                .attr('stroke-width', 4);
            timeSeries.append('circle')
                .attr('class', 'as-time-series--scrubber')
                .attr('r', SCRUBBER_SIZE)
                .attr('stroke-width', 0);
            timeSeries.append('line')
                .attr('class', 'as-time-series--track')
                .attr('stroke-width', 16)
                .attr('stroke', 'black')
                .attr('opacity', '0')
                .on('mouseleave', () => {
                this._lastMousePosition = -1;
                timeSeries.select('.as-time-series--preview')
                    .attr('opacity', '0');
            });
        }
        timeSeries.select('.as-time-series--line')
            .attr('x1', progressScale(0) - (SCRUBBER_SIZE / 2))
            .attr('x2', xPos)
            .attr('y1', height - Y_PADDING)
            .attr('y2', height - Y_PADDING);
        timeSeries.select('.as-time-series--track')
            .attr('y1', height - Y_PADDING)
            .attr('y2', height - Y_PADDING)
            .attr('x1', progressScale(0) + trackOffset)
            .attr('x2', progressScale(100) - trackOffset)
            .on('mousemove', () => {
            const evt = index.event;
            this._lastMousePosition = evt.clientX - left - X_PADDING + 8;
            if (this._lastMousePosition > progressScale(this.progress)) {
                timeSeries.select('.as-time-series--preview')
                    .attr('x2', this._lastMousePosition)
                    .attr('opacity', '1');
            }
        });
        timeSeries.select('.as-time-series--preview')
            .attr('x1', xPos - (SCRUBBER_SIZE / 2))
            .attr('y1', height - Y_PADDING)
            .attr('y2', height - Y_PADDING)
            .attr('opacity', () => {
            if (this._lastMousePosition > xPos) {
                return '1';
            }
            return '0';
        });
        timeSeries.select('.as-time-series--scrubber')
            .attr('transform', `translate(${xPos - (SCRUBBER_SIZE / 2)},${height - Y_PADDING})`);
    }
    static get watchers() { return {
        "data": ["onDataChanged"],
        "backgroundData": ["onBackgroundDataChanged"],
        "progress": ["onProgressChanged"],
        "timeFormat": ["onTimeFormatChanged"],
        "timeFormatLocale": ["onTimeFormatLocaleChanged"]
    }; }
    static get style() { return "as-time-series-widget{--as--time-series--line-color:var(--as--color--primary,#1785fb);--as-histogram-widget--background-color:var(--as--color--ui-01);display:-ms-flexbox;display:flex;-ms-flex-align:end;align-items:flex-end;height:100%;background:var(--as-histogram-widget--background-color,#fff)}as-time-series-widget as-histogram-widget{overflow:unset}as-time-series-widget.as-time-series--animated as-histogram-widget .content,as-time-series-widget.as-time-series--animated as-histogram-widget as-widget-header,as-time-series-widget.as-time-series--animated as-histogram-widget as-widget-selection{margin-left:-32px}as-time-series-widget .as-time-series--play-button{margin-bottom:2px;cursor:pointer}as-time-series-widget .as-time-series--play-button-hidden{opacity:0}as-time-series-widget .as-time-series--play-button-x-label{margin-bottom:27px}as-time-series-widget .as-time-series--line,as-time-series-widget .as-time-series--scrubber{stroke:var(--as--time-series--line-color);fill:var(--as--time-series--line-color)}as-time-series-widget .as-time-series--line,as-time-series-widget .as-time-series--scrubber,as-time-series-widget .as-time-series--track{cursor:pointer}"; }
};

exports.as_time_series_widget = TimeSeriesWidget;
