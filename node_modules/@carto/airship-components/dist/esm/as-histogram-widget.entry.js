import { r as registerInstance, c as createEvent, h, g as getElement } from './core-a69618da.js';
import { c as contentFragment } from './content.fragment-e220039c.js';
import { r as readableNumber } from './readable-number-b11b551f.js';
import { s as shadeOrBlend } from './styles-b283ec9e.js';
import { e as event, s as select, v as interpolate, w as customEvent, x as touch, y as mouse, l as linear, z as min, A as max, B as format } from './index-3374c455.js';
import { d as dispatch, i as interrupt } from './index-c73eaaa7.js';
import { b as axisBottom, a as axisLeft } from './index-87eae0eb.js';
import { D as DEFAULT_BAR_COLOR, a as DEFAULT_BACKGROUND_BAR_COLOR, d as DEFAULT_BAR_COLOR_HEX, e as DEFAULT_BACKGROUND_BAR_COLOR_HEX } from './constants-2231320f.js';

function noevent() {
  event.preventDefault();
  event.stopImmediatePropagation();
}

function dragDisable(view) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", noevent, true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent, true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

function constant(x) {
  return function() {
    return x;
  };
}

function BrushEvent(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
}

function nopropagation() {
  event.stopImmediatePropagation();
}

function noevent$1() {
  event.preventDefault();
  event.stopImmediatePropagation();
}

var MODE_DRAG = {name: "drag"},
    MODE_SPACE = {name: "space"},
    MODE_HANDLE = {name: "handle"},
    MODE_CENTER = {name: "center"};

function number1(e) {
  return [+e[0], +e[1]];
}

function number2(e) {
  return [number1(e[0]), number1(e[1])];
}

function toucher(identifier) {
  return function(target) {
    return touch(target, event.touches, identifier);
  };
}

var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !event.ctrlKey && !event.button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

// Like d3.local, but with the name “__brush” rather than auto-generated.
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushX() {
  return brush(X);
}

function brush(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      touchable = defaultTouchable,
      keys = true,
      listeners = dispatch("start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", "all")
        .attr("cursor", cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local(this).extent;
          select(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([type("selection")])
      .enter().append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .on("mousedown.brush", started)
      .filter(touchable)
        .on("touchstart.brush", started)
        .on("touchmove.brush", touchmoved)
        .on("touchend.brush touchcancel.brush", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  brush.move = function(group, selection) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                i = interpolate(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && selection1 === null ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 !== null && selection1 !== null ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                emit = emitter(that, args).beforestart();

            interrupt(that);
            state.selection = selection1 === null ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  brush.clear = function(group) {
    brush.move(group, null);
  };

  function redraw() {
    var group = select(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection[0][0])
          .attr("y", selection[0][1])
          .attr("width", selection[1][0] - selection[0][0])
          .attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args, clean) {
    return (!clean && that.__brush.emitter) || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      else this.emit("brush");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (touchending && !event.touches) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = event.target.__data__.type,
        mode = (keys && event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && event.altKey ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx = 0,
        dy = 0,
        moving,
        shifting = signX && signY && keys && event.shiftKey,
        lockX,
        lockY,
        pointer = event.touches ? toucher(event.changedTouches[0].identifier) : mouse,
        point0 = pointer(that),
        point = point0,
        emit = emitter(that, arguments, true).beforestart();

    if (type === "overlay") {
      if (selection) moving = true;
      state.selection = selection = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = select(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = select(event.view)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);
      if (keys) view
          .on("keydown.brush", keydowned, true)
          .on("keyup.brush", keyupped, true);

      dragDisable(event.view);
    }

    nopropagation();
    interrupt(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = pointer(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      noevent$1();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1
          || selection[0][1] !== n1
          || selection[1][0] !== e1
          || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      nopropagation();
      if (event.touches) {
        if (event.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
      } else {
        yesdrag(event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (event.keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      noevent$1();
    }

    function keyupped() {
      switch (event.keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (event.altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      noevent$1();
    }
  }

  function touchmoved() {
    emitter(this, arguments).moved();
  }

  function touchended() {
    emitter(this, arguments).ended();
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = number2(extent.apply(this, arguments));
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant(number2(_)), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), brush) : filter;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.keyModifiers = function(_) {
    return arguments.length ? (keys = !!_, brush) : keys;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

function addBrush(width, height, onBrush, onBrushEnd, CUSTOM_HANDLE_WIDTH, CUSTOM_HANDLE_HEIGHT, X_PADDING, Y_PADDING) {
    return brushX()
        .handleSize(CUSTOM_HANDLE_WIDTH)
        .extent([[0, 0], [width - X_PADDING, height - Y_PADDING + (CUSTOM_HANDLE_HEIGHT / 2)]])
        .on('brush', onBrush)
        .on('end', onBrushEnd);
}
function addBrushArea(brush, container) {
    let brushArea = container.select('g.brush');
    if (brushArea.empty()) {
        brushArea = container.append('g');
        brushArea.attr('class', 'brush');
    }
    brushArea.call(brush);
    return brushArea;
}
function addCustomHandles(brushArea, CUSTOM_HANDLE_WIDTH, CUSTOM_HANDLE_HEIGHT, scale) {
    let bottomLine = brushArea.select('line.bottomline');
    if (bottomLine.empty()) {
        bottomLine = brushArea.append('line')
            .attr('class', 'bottomline')
            .attr('stroke-width', 4)
            .style('opacity', 0)
            .attr('pointer-events', 'none');
    }
    bottomLine
        .attr('y1', scale(0))
        .attr('y2', scale(0));
    let customHandles = brushArea.selectAll('.handle--wrapper');
    const linesMargin = Math.floor((CUSTOM_HANDLE_WIDTH - 2) / 2);
    if (customHandles.empty()) {
        customHandles = customHandles
            .data([{ type: 'w' }, { type: 'e' }])
            .enter()
            .append('g')
            .attr('class', 'handle--wrapper');
        customHandles
            .append('rect')
            .attr('class', 'handle--custom')
            .attr('width', CUSTOM_HANDLE_WIDTH)
            .attr('height', CUSTOM_HANDLE_HEIGHT)
            .attr('rx', 1)
            .attr('ry', 1);
        const handleGrab = customHandles
            .append('g')
            .attr('class', 'handle--grab');
        for (let i = 0; i < 3; i++) {
            handleGrab
                .append('line')
                .attr('transform', `translate(0 ${(CUSTOM_HANDLE_HEIGHT / 2) - 2})`)
                .attr('x1', linesMargin)
                .attr('y1', i * 2)
                .attr('x2', CUSTOM_HANDLE_WIDTH - linesMargin)
                .attr('y2', i * 2)
                .attr('class', 'grab-line');
        }
    }
    return customHandles;
}
const brushService = { addBrush, addBrushArea, addCustomHandles };

function binsScale(data) {
    return linear()
        .domain(getXDomain(data))
        .range([0, data.length]);
}
function getXDomain(data) {
    const { start } = data.length > 0 ? data[0] : { start: 0 };
    const { end } = data.length > 0 ? data[data.length - 1] : { end: 0 };
    return [start, end];
}
function getYDomain(data) {
    return [Math.min(0, getLowerBounds(data)), max(data, (d) => d.value)];
}
function getLowerBounds(data) {
    return min(data, (d) => d.value);
}
function getXScale(domain, width) {
    return linear()
        .domain(domain)
        .range([0, width]);
}
function isCategoricalData(data) {
    // Histogram data is categorical if all elements contain the category property
    return data.every(_hasCategory);
}
function prepareData(data) {
    const hasRange = data.every(_hasRange);
    return data.map((d, index) => {
        const parsed = Object.assign({}, d);
        if (!hasRange) {
            parsed.start = index;
            parsed.end = index + 1;
        }
        return parsed;
    });
}
function _hasCategory(data) {
    return data.category !== undefined;
}
function _hasRange(data) {
    return data.start !== undefined && data.end !== undefined;
}
/**
 * Checks if an array of data and background data are compatible
 */
function isBackgroundCompatible(data, backgroundData) {
    const isNull = [data, backgroundData].map((value) => value === null);
    // Both must be null or both must not be null
    if (isNull[0] !== isNull[1]) {
        return false;
    }
    // If both are null, they're automatically compatible
    if (isNull[0] && isNull[1]) {
        return true;
    }
    // They must have the same length
    if (data.length !== backgroundData.length) {
        return true;
    }
    const isCategorical = data.every(_hasCategory);
    const hasRange = data.every(_hasRange);
    for (let index = 0; index < data.length; index++) {
        // If every element has start / end, they must be equal on both arrays for every element
        if (hasRange) {
            if (backgroundData[index].start !== data[index].start ||
                backgroundData[index].end !== data[index].end) {
                return false;
            }
        }
        // If every element has category, they must be equal on both arrays for every element
        if (isCategorical) {
            if (backgroundData[index].category !== data[index].category) {
                return false;
            }
        }
    }
    return true;
}
const dataService = {
    getLowerBounds,
    getXDomain,
    getXScale,
    getYDomain,
    isBackgroundCompatible,
    isCategoricalData,
    prepareData,
};

const BAR_WIDTH_THRESHOLD = 3;
const formatter = format('.2~s');
const decimalFormatter = format('.2');
function cleanAxes(yAxisSelection) {
    yAxisSelection.select('.domain').remove();
}
function updateAxes(container, xScale, yScale, xAxis, yAxis, xDomain, yDomain) {
    const xAxisSelection = container.select('.xAxis');
    const yAxisSelection = container.select('.yAxis');
    // -- Update scales
    yScale
        .domain(yDomain)
        .nice();
    xScale
        .domain(xDomain);
    // -- Update axes
    xAxisSelection
        .call(xAxis);
    yAxisSelection
        .call(yAxis);
}
function renderPlot(container) {
    if (container.select('.plot').empty()) {
        const barsContainer = container
            .append('g');
        barsContainer
            .attr('class', 'plot');
        return barsContainer;
    }
    return container.select('.plot');
}
function renderBars(data, yScale, container, barsContainer, color, X_PADDING, Y_PADDING, disableAnimation = false, className = '') {
    if (!container || !container.node()) {
        return;
    }
    let barsSeparation = 1;
    const HEIGHT = container.node().getBoundingClientRect().height - Y_PADDING;
    const WIDTH = container.node().getBoundingClientRect().width - X_PADDING;
    data = data === null ? [] : data;
    const barWidth = data.length === 0 ? WIDTH : WIDTH / data.length;
    if (barWidth - barsSeparation < BAR_WIDTH_THRESHOLD) {
        barsSeparation = 0;
    }
    // -- Draw bars
    this.bars = barsContainer
        .selectAll(`rect.${className}`)
        .data(data);
    // -- Exit
    this.bars.exit().remove()
        .transition()
        .duration(200);
    // -- Enter
    const mergeSelection = this.bars
        .enter()
        .append('rect')
        .attr('y', HEIGHT)
        .attr('height', 0)
        .merge(this.bars)
        .attr('class', `bar ${className}`)
        .attr('x', (_d, index) => index * barWidth)
        .attr('width', () => Math.max(0, barWidth - barsSeparation))
        .style('fill', (d) => d.color || color);
    const minDomain = yScale.domain()[0];
    const yZero = yScale(Math.max(0, minDomain));
    (disableAnimation ? mergeSelection : mergeSelection.transition().delay(_delayFn))
        .attr('height', (d) => {
        return Math.abs(yScale(d.value) - yZero);
    })
        .attr('y', (d) => d.value > 0 ? yScale(d.value) : yZero);
    // -- Update
    (disableAnimation ? this.bars : this.bars.transition().delay(_delayFn))
        .attr('height', (d) => {
        return Math.abs(yScale(d.value) - yZero);
    })
        .attr('y', (d) => d.value > 0 ? yScale(d.value) : yZero);
}
function renderXAxis(container, domain, bins, X_PADDING, Y_PADDING, customFormatter = conditionalFormatter, axisOptions) {
    if (!container || !container.node()) {
        return;
    }
    const HEIGHT = container.node().getBoundingClientRect().height - Y_PADDING;
    const WIDTH = container.node().getBoundingClientRect().width - X_PADDING;
    // Display first, last and middle point bins
    const tickValues = [0, bins / 2, bins];
    const tickPadding = axisOptions.padding !== undefined ? axisOptions.padding : 13;
    const ticks = axisOptions.ticks !== undefined ? axisOptions.ticks : tickValues.length;
    const xScale = linear()
        .domain([0, bins])
        .range([0, WIDTH]);
    const realScale = linear()
        .domain(domain)
        .range([0, bins]);
    let xAxis;
    if (axisOptions.values || axisOptions.format) {
        const altScale = linear()
            .domain(domain)
            .range([0, WIDTH]);
        xAxis = axisBottom(altScale)
            .tickValues(axisOptions.values || null)
            .tickFormat(axisOptions.format || customFormatter);
    }
    else {
        xAxis = axisBottom(xScale)
            // tickValues has precedence over ticks, must set null if user wants custom tick number
            .tickValues(ticks !== undefined ? null : tickValues)
            .tickFormat((value) => {
            const realValue = realScale.invert(value);
            return customFormatter(realValue);
        });
    }
    xAxis
        .tickSize(-HEIGHT)
        .tickPadding(tickPadding)
        .ticks(ticks);
    if (container.select('.x-axis').empty()) {
        container
            .append('g')
            .attr('class', 'x-axis')
            .attr('transform', `translate(0, ${HEIGHT})`)
            .call(xAxis);
    }
    else {
        container
            .select('.x-axis')
            .attr('transform', `translate(0, ${HEIGHT})`)
            .call(xAxis);
    }
    container.selectAll('.x-axis text')
        .attr('transform', (_d, i, collection) => {
        const node = collection[i];
        const { width } = node.getBoundingClientRect();
        let xOffset = 0;
        if (i === 0) {
            xOffset = width / 2;
        }
        else if (i === collection.length - 1) {
            xOffset = -width / 2;
        }
        return `translate(${xOffset})`;
    })
        .attr('opacity', (_d, i, collection) => {
        // We never hide the first or the last text node
        if (i === 0 || i === collection.length - 1) {
            return 1;
        }
        let textWidth = 0;
        const textElements = collection;
        for (const textEl of textElements) {
            textWidth += textEl.getBoundingClientRect().width;
        }
        // Hide all other text nodes when there's not enough space
        if (WIDTH - textWidth < 0) {
            return 0;
        }
        return 1;
    });
    return xAxis;
}
function renderYAxis(container, yAxis, X_PADDING) {
    if (!container || !container.node()) {
        return;
    }
    if (container.select('.y-axis').empty()) {
        container
            .append('g')
            .attr('class', 'y-axis')
            .call(yAxis);
    }
    else {
        container.select('.y-axis')
            .call(yAxis);
    }
    // 0 line
    container
        .select('.y-axis')
        .append('g')
        .attr('class', 'tick')
        .attr('opacity', '1')
        .attr('transform', `translate(0,${yAxis.scale()(0)})`)
        .append('line')
        .attr('shape-rendering', 'crisp')
        .attr('stroke', '#000')
        .attr('class', 'zero')
        .attr('x2', container.node().getBoundingClientRect().width - X_PADDING);
}
function generateYScale(container, domain, X_PADDING, Y_PADDING, axisOptions) {
    if (!container || !container.node()) {
        return;
    }
    const HEIGHT = container.node().getBoundingClientRect().height - Y_PADDING;
    const WIDTH = container.node().getBoundingClientRect().width - X_PADDING;
    const ticks = axisOptions.ticks !== undefined ? axisOptions.ticks : 5;
    const tickPadding = axisOptions.padding !== undefined ? axisOptions.padding : 10;
    // -- Y Axis
    const yScale = linear()
        .domain(domain)
        .range([HEIGHT, 0]);
    const yAxis = axisLeft(yScale)
        .tickSize(-WIDTH)
        .ticks(ticks)
        .tickPadding(tickPadding)
        .tickFormat(axisOptions.format || conditionalFormatter)
        .tickValues(axisOptions.values || null);
    return yAxis;
}
function _delayFn(_d, i) {
    return i;
}
function conditionalFormatter(value) {
    if (value > 0 && value < 1) {
        return decimalFormatter(value);
    }
    return formatter(value);
}
const drawService = {
    cleanAxes,
    conditionalFormatter,
    generateYScale,
    renderBars,
    renderPlot,
    renderXAxis,
    renderYAxis,
    updateAxes
};

function addTooltip(container, barsContainer, hasSelection, color, unselectedColor, formatter, setTooltip, className) {
    container.on('mousemove', () => {
        const evt = event;
        const { clientX, clientY } = evt;
        let anyHovered = false;
        _forEachRect(barsContainer, clientX, clientY, className, async (data, node, bucketIndex, boundingBox) => {
            const selected = _isSelected(hasSelection.selection, bucketIndex);
            let _color = selected ? data.color || color : unselectedColor;
            _color = shadeOrBlend(-0.16, _color);
            node.style('fill', _color);
            const tooltip = await formatter(data);
            setTooltip(tooltip, boundingBox, evt);
            anyHovered = true;
        }, (data, node, bucketIndex) => {
            const selected = _isSelected(hasSelection.selection, bucketIndex);
            node.style('fill', selected ? data.color || color : unselectedColor);
        });
        if (!anyHovered) {
            setTooltip(null, null);
        }
    })
        .on('click', () => {
        const evt = event;
        const { clientX, clientY } = evt;
        _forEachRect(barsContainer, clientX, clientY, className, (data) => {
            hasSelection.setSelection([data.start, data.end], true);
        });
    })
        .on('mouseleave', () => {
        setTooltip(null, null);
        barsContainer.selectAll(`rect.${className}`)
            .style('fill', (data, bucketIndex) => {
            if (_isSelected(hasSelection.selection, bucketIndex)) {
                return data.color || color;
            }
            return unselectedColor;
        });
    });
}
function _isSelected(range, bucketIndex) {
    if (range === null) {
        return true;
    }
    return bucketIndex >= range[0] && bucketIndex < range[1];
}
/**
 * Cycles through all rects in container, fires a callback for the rect that contains the x / y points,
 * and fires another (optional) callback for the rest of the containers
 *
 * @param {SVGGContainer} container Container that contains rect elements
 * @param {number} x X coordinate to check whether is contained or not
 * @param {number} y Y coordinate to check whether is contained or not
 * @param {RectCallback} insideCallback Callback fired with data of bucket that contains the point
 * @param {RectCallback} [outsideCallback] Callback fired with data of buckets that don't contain the point
 */
function _forEachRect(container, x, y, className, insideCallback, outsideCallback) {
    container.selectAll(`rect.${className}`)
        .each((data, i, nodes) => {
        const nodeSelection = select(nodes[i]);
        const node = nodes[i];
        const bb = node.getBoundingClientRect();
        const isInsideBB = bb.left <= x &&
            x <= bb.right &&
            bb.top <= y &&
            y <= bb.bottom;
        if (isInsideBB) {
            insideCallback(data, nodeSelection, i, bb);
            return;
        }
        if (outsideCallback) {
            outsideCallback(data, nodeSelection, i, null);
        }
    });
}
const interactionService = { addTooltip };

const CUSTOM_HANDLE_WIDTH = 8;
const CUSTOM_HANDLE_HEIGHT = 20;
// we could use getComputedStyle instead of these
const X_PADDING = 38;
const Y_PADDING = 40;
const LABEL_PADDING = 25;
const FG_CLASSNAME = 'foreground-bar';
const BG_CLASSNAME = 'background-bar';
const HistogramWidget = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * Toggles displaying title and description
         *
         * @type {boolean}
         * @memberof HistogramWidget
         */
        this.showHeader = true;
        /**
         * Disables selection brushes and events for the widget
         *
         * @type {boolean}
         * @memberof HistogramWidget
         */
        this.disableInteractivity = false;
        /**
         * Histogram data to be displayed
         *
         * @type {HistogramData[]}
         * @memberof HistogramWidget
         */
        this.data = [];
        /**
         * Data that will be merged into buckets with value === 0
         *
         * @type {HistogramData[]}
         * @memberof HistogramWidget
         */
        this.backgroundData = null;
        /**
         * Override color for the histogram bars
         *
         * @type {string}
         * @memberof HistogramWidget
         */
        this.color = DEFAULT_BAR_COLOR;
        /**
         * Override color for the non selected histogram bars
         *
         * @type {string}
         * @memberof HistogramWidget
         */
        this.unselectedColor = DEFAULT_BACKGROUND_BAR_COLOR;
        /**
         * Function that formats the tooltip. Receives HistogramData and outputs a string
         *
         * @type {(HistogramData) => string}
         * @memberof HistogramWidget
         */
        this.tooltipFormatter = this.formatter;
        /**
         * Use this attribute to put the widget in "loading mode".
         * When loading mode is active, a spinner will be shown and the data will be hidden.
         */
        this.isLoading = false;
        /**
         * Use this widget to put the widget in "error mode".
         * When error mode is active. The header will display the given text.
         * And the body will be display the errorDescription instead any data.
         */
        this.error = '';
        /**
         * Extended error description, only shown when error is present
         */
        this.errorDescription = '';
        /**
         * Message shown in header when no data is available
         */
        this.noDataHeaderMessage = 'NO DATA AVAILABLE';
        /**
         * Message shown in body when no data is available
         */
        this.noDataBodyMessage = 'There is no data to display.';
        /**
         * Use this attribute to decide if the widget should be rerendered on window resize.
         * Defaults to true.
         */
        this.responsive = true;
        /**
         * Text rendered inside the clear selection button
         */
        this.clearText = 'Clear selection';
        /**
         * Function to format the range selected text displayed below the histogram
         *
         * @memberof HistogramWidget
         */
        this.selectedFormatter = this._selectionFormatter;
        /**
         * This prop lets you provide the range of the y-axis so it's not automatically calculated with
         * data or backgroundData. It always starts at 0, you can provide the top value.
         *
         * @memberof HistogramWidget
         */
        this.range = null;
        /**
         * This lets you disable the animations for the bars when showing / updating the data
         *
         * @type {boolean}
         * @memberof HistogramWidget
         */
        this.disableAnimation = false;
        /**
         * This prop is a proxy to some d3-axis options for the X Axis
         *
         * @type {AxisOptions}
         * @memberof TimeSeriesWidget
         */
        this.xAxisOptions = {};
        /**
         * This prop is a proxy to some d3-axis options for the Y Axis
         *
         * @type {AxisOptions}
         * @memberof TimeSeriesWidget
         */
        this.yAxisOptions = {};
        this.selection = null;
        this.tooltip = null;
        this._firstDataSupplied = false;
        this._muteSelectionChanged = false;
        this._lastEmittedSelection = null;
        this.selectionEmpty = true;
        this.selectionFooter = '';
        this._resizeRender = this._resizeRender.bind(this);
        this._setTooltip = this._setTooltip.bind(this);
        this.selectionChanged = createEvent(this, "selectionChanged", 7);
        this.selectionInput = createEvent(this, "selectionInput", 7);
        this.drawParametersChanged = createEvent(this, "drawParametersChanged", 7);
    }
    _onBackgroundDataChanged(newBackgroundData) {
        if (newBackgroundData === null || newBackgroundData.length === 0) {
            this._prepareData(this.data, null);
            return;
        }
        if (isBackgroundCompatible(this.data, newBackgroundData)) {
            this._prepareData(this.data, newBackgroundData);
        }
    }
    _onDataChanged(newData, oldData) {
        this.onNewData(newData, oldData);
        if (!this._firstDataSupplied) {
            this._firstDataSupplied = Boolean(newData && newData.length);
        }
    }
    onNewData(newData, oldData) {
        // Invalidated, indexes might be different data now
        this._lastEmittedSelection = null;
        if (isBackgroundCompatible(newData, this.backgroundData)) {
            this._prepareData(this.data, this.backgroundData, oldData);
        }
        else {
            this._prepareData(this.data, null, oldData);
        }
    }
    _prepareData(data, backgroundData, oldData) {
        this._data = prepareData(data);
        this._backgroundData = backgroundData === null ? this._mockBackgroundData(data) : prepareData(backgroundData);
        const newScale = binsScale(this._data);
        const wasCategoricalData = !!this.isCategoricalData;
        this.isCategoricalData = isCategoricalData(this._data);
        if (wasCategoricalData !== this.isCategoricalData) {
            this.selection = null;
        }
        else {
            this.selection = this._preadjustSelection(oldData, newScale, data.length);
        }
        this.binsScale = newScale;
        this._muteSelectionChanged = true;
        this._dataJustChanged = true;
    }
    _onColorChanged(newColor) {
        const incomingColor = newColor || DEFAULT_BAR_COLOR;
        this._color = this._toColor(incomingColor, DEFAULT_BAR_COLOR_HEX);
    }
    _onSelectedColorChanged(newColor) {
        const incomingColor = newColor || DEFAULT_BACKGROUND_BAR_COLOR;
        this._barBackgroundColor = this._toColor(incomingColor, DEFAULT_BACKGROUND_BAR_COLOR_HEX);
    }
    /**
     * Default formatting function. Makes the value a readable number and
     * converts it into a string. Useful to compose with your own formatting
     * function.
     *
     * @memberof HistogramWidget
     */
    async defaultFormatter(data) {
        return this.formatter(data);
    }
    /**
     * Returns the current selection
     *
     * @returns {number[] | string[]}
     * @memberof HistogramWidget
     */
    async getSelection() {
        const data = this._dataForSelection(this.selection);
        return this._simplifySelection(data);
    }
    /**
     * Programmatically set the selection. It will be adjusted to the buckets
     * present in {@link data}. To clear see {@link clearSelection} or call with null
     *
     * @param {number[] | null} values
     * @param {boolean} emit Set to true to force emitting the selectionChanged event.
     * @memberof HistogramWidget
     */
    async setSelection(values, emit = false) {
        if (values === null) {
            this._setSelection(null);
            this.emitSelection(this.selectionChanged, this.selection);
            return;
        }
        // This is too tricky, we'd have to make sure that categories are contiguous
        if (values.some((value) => typeof value === 'string')) {
            return;
        }
        const bins = values.map(this.binsScale);
        this._setSelection(bins);
        if (emit || !this._muteSelectionChanged) {
            this.emitSelection(this.selectionChanged, this.selection);
        }
    }
    /**
     * Clears the Histogram selection
     *
     * @memberof HistogramWidget
     */
    async clearSelection() {
        this.setSelection(null);
    }
    /**
     * Formats a number using the component's x-axis formatter if present
     *
     * @memberof HistogramWidget
     */
    async xFormatter(value) {
        return this._xFormatter(value);
    }
    componentDidLoad() {
        this._color = this._toColor(this.color, DEFAULT_BAR_COLOR_HEX);
        this._barBackgroundColor = this._toColor(this.unselectedColor, DEFAULT_BACKGROUND_BAR_COLOR_HEX);
        if (!this._hasDataToDisplay()) {
            return;
        }
        this.isCategoricalData = isCategoricalData(this._data);
        requestAnimationFrame(() => {
            this._renderGraph();
        });
    }
    componentDidUpdate() {
        if (!this._dataJustChanged) {
            return;
        }
        this._renderGraph();
        this._dataJustChanged = false;
    }
    componentWillLoad() {
        addEventListener('resize', this._resizeRender);
        this._firstDataSupplied = Boolean(this.data && this.data.length);
        this.selectionFooter = this.selectedFormatter(this.selection);
        this._onBackgroundDataChanged(this.backgroundData);
        this.onNewData(this.data, null);
    }
    componentDidUnload() {
        removeEventListener('resize', this._resizeRender);
    }
    render() {
        if (this._isLoading()) {
            return (h("as-histogram-widget-placeholder", null, this._renderHeader()));
        }
        return [
            this._renderHeader(),
            this._renderSelection(),
            this._renderContent(),
        ];
    }
    _resizeRender() {
        requestAnimationFrame(() => {
            this._renderGraph();
        });
    }
    _renderContent() {
        const histogramClasses = {
            'as-histogram-widget--categorical': this.isCategoricalData,
            'as-histogram-widget__wrapper': true,
            'as-histogram-widget__wrapper--disabled': this.disableInteractivity
        };
        const svgClasses = {
            'figure': true,
            'figure--has-x-label': !!this.xLabel,
            'figure--has-y-label': !!this.yLabel
        };
        return contentFragment(this._isLoading(), this.error, this._isEmpty(), this.heading, this.errorDescription, this.noDataBodyMessage, h("div", { class: histogramClasses }, h("svg", { class: svgClasses, ref: (ref) => this.container = select(ref) }), this._renderLabels(), this._renderTooltip()));
    }
    _mockBackgroundData(data) {
        const min = dataService.getLowerBounds(data);
        return data.map((value) => (Object.assign({}, value, { value: Math.max(0, min) })));
    }
    _selectionFormatter(selection) {
        if (selection === null) {
            return 'All selected';
        }
        if (this.isCategoricalData) {
            return `${selection[1] - selection[0]} selected`;
        }
        let formattedSelection;
        const domainSelection = selection.map(this.binsScale.invert);
        if (this.axisFormatter) {
            formattedSelection = domainSelection.map(this.axisFormatter);
        }
        else {
            formattedSelection = domainSelection.map((e) => `${conditionalFormatter(e)}`);
        }
        return `Selected from ${formattedSelection[0]} to ${formattedSelection[1]}`;
    }
    _renderSelection() {
        if (this._isLoading() || this._isEmpty() || this.error || !this.showClear) {
            return '';
        }
        return h("as-widget-selection", { selection: this.selectionFooter, clearText: this.clearText, showClear: !this.selectionEmpty, onClear: () => this.clearSelection() });
    }
    _renderGraph() {
        if (!this.container || !this.container.node()) {
            return;
        }
        const bbox = this.container.node().getBoundingClientRect();
        const firstRender = this.prevWidth === undefined || this.prevHeight === undefined;
        this.prevWidth = this.width;
        this.prevHeight = this.height;
        this.width = bbox.width;
        this.height = bbox.height;
        const resizing = !firstRender && (this.prevWidth !== this.width || this.height !== this.prevHeight);
        if (this.height === 0 || this.width === 0) {
            return;
        }
        this._generateYAxis();
        this._renderXAxis();
        this.barsContainer = drawService.renderPlot(this.container);
        interactionService.addTooltip(this.container, this.barsContainer, this, this._color, this._barBackgroundColor, (value) => this.tooltipFormatter(value), this._setTooltip, FG_CLASSNAME);
        drawService.renderBars(this._backgroundData, this.yScale, this.container, this.barsContainer, this._barBackgroundColor, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING, this.disableAnimation || resizing, BG_CLASSNAME);
        drawService.renderBars(this._data, this.yScale, this.container, this.barsContainer, this._color, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING, this.disableAnimation || resizing, FG_CLASSNAME);
        drawService.renderYAxis(this.container, this.yAxis, X_PADDING);
        if (!this.disableInteractivity) {
            this.brush = brushService.addBrush(this.width, this.height, this._onBrush.bind(this), this._onBrushEnd.bind(this), CUSTOM_HANDLE_WIDTH, CUSTOM_HANDLE_HEIGHT, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING);
            this.brushArea = brushService.addBrushArea(this.brush, this.container);
            this.customHandles = brushService.addCustomHandles(this.brushArea, CUSTOM_HANDLE_WIDTH, CUSTOM_HANDLE_HEIGHT, this.yScale);
        }
        this._updateSelection();
        this.drawParametersChanged.emit({
            binsScale: this.binsScale,
            container: this.container,
            handleWidth: CUSTOM_HANDLE_WIDTH,
            height: this.height,
            padding: [X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING],
            width: this.width,
            xScale: this.xScale
        });
        this._muteSelectionChanged = false;
    }
    _setTooltip(value, barBBox) {
        if (value === null) {
            this._hideTooltip();
            return;
        }
        this.tooltip = value;
        this._showTooltip(barBBox);
    }
    _updateSelection() {
        if (this.selection === null || this.disableInteractivity) {
            return;
        }
        if (this._selectionInData(this.selection)) {
            this._setSelection(this.selection);
        }
        else {
            this.clearSelection();
        }
    }
    _adjustSelection(values) {
        if (values === null) {
            return null;
        }
        return values.map((value) => this._adjustSelectionValue(value));
    }
    _adjustSelectionValue(value) {
        if (value < 0) {
            return 0;
        }
        if (value >= this._data.length) {
            return this._data.length;
        }
        return Math.round(value);
    }
    _hideCustomHandles() {
        this.customHandles.style('opacity', 0);
        this.brushArea.selectAll('.bottomline').style('opacity', 0);
    }
    _onBrush() {
        if (this.disableInteractivity) {
            return;
        }
        const evt = event; // I can't cast this properly :(
        if (evt.selection === null) {
            this._hideCustomHandles();
            return;
        }
        // I don't know why this happens
        if (!evt.sourceEvent || evt.sourceEvent.type === 'brush') {
            return;
        }
        // Convert to our data's domain
        const d0 = evt.selection
            .map((selection) => this.xScale.invert(selection));
        this._setSelection(d0);
    }
    _onBrushEnd() {
        if (this.disableInteractivity) {
            return;
        }
        if (!this._muteSelectionChanged) {
            this.emitSelection(this.selectionChanged, this.selection);
        }
    }
    _setSelection(selection) {
        if (this.disableInteractivity) {
            return;
        }
        const adjustedSelection = this._adjustSelection(selection);
        if (adjustedSelection !== null && (adjustedSelection[0] === adjustedSelection[1])) {
            return;
        }
        const sameSelection = this.selection !== null &&
            adjustedSelection !== null &&
            this.selection.every((d, i) => adjustedSelection[i] === d);
        this.selection = adjustedSelection;
        this._updateHandles(adjustedSelection);
        if (!sameSelection) {
            this._hideTooltip();
            this.emitSelection(this.selectionInput, this.selection);
        }
        this.selectionEmpty = this.selection === null;
        this.selectionFooter = this.selectedFormatter(this.selection);
    }
    // Adjust the selection to the new data
    _preadjustSelection(oldData, newScale, nBuckets) {
        if (!(oldData && this.selection)) {
            return this.selection;
        }
        // For categorical data, we map back the previously selected values into indexes, and return [first, last]
        if (this.isCategoricalData) {
            const selectedCats = this._simplifySelection(this._dataForSelection(this.selection, oldData));
            const selection = selectedCats.map((value) => {
                return this._data.findIndex((d) => d.category === value);
            });
            // At least one of the previous values are missing, we clear the selection
            if (selection.some((e) => e === -1)) {
                return null;
            }
            return [selection[0], selection[selection.length - 1] + 1];
        }
        const oldSelection = this._simplifySelection(this._dataForSelection(this.selection, oldData));
        const newSelection = oldSelection.map(newScale).map(Math.round);
        return [Math.max(0, newSelection[0]), Math.min(nBuckets, newSelection[1])];
    }
    _dataForSelection(selection, from) {
        if (selection === null) {
            return null;
        }
        const data = from !== undefined ? from : this.data;
        if (this.isCategoricalData) {
            return data
                .slice(selection[0], selection[1])
                .map((d) => d);
        }
        return [data[selection[0]], data[selection[1] - 1]];
    }
    _simplifySelection(selection) {
        if (selection === null) {
            return null;
        }
        if (this.isCategoricalData) {
            return selection.map((value) => value.category);
        }
        return [selection[0].start, selection[selection.length - 1].end];
    }
    _sameSelection(first, second) {
        if (first === null || second === null) {
            return false;
        }
        return (first[0] === second[0] && first[1] === second[1]);
    }
    emitSelection(emitter, selection) {
        if (this._sameSelection(selection, this._lastEmittedSelection)) {
            return;
        }
        if (selection === null) {
            emitter.emit(null);
            return;
        }
        const payload = this._dataForSelection(selection);
        const evt = {
            payload,
            selection: this._simplifySelection(payload),
            type: this._eventType()
        };
        emitter.emit(evt);
        if (emitter === this.selectionChanged) {
            this._lastEmittedSelection = [selection[0], selection[1]];
        }
    }
    _eventType() {
        return this.isCategoricalData ? 'categorical' : 'continuous';
    }
    _selectionInData(selection) {
        const domainSelection = selection.map(this.binsScale.invert);
        const inData = domainSelection.map((selectionValue) => {
            return this._data.some((value) => selectionValue >= value.start && selectionValue <= value.end);
        });
        // True if any of the selection values is inside the data
        // Using inData.every(e => e) would be more restrictive
        return inData.some((e) => e);
    }
    _updateHandles(values) {
        if (!this.xScale) {
            return;
        }
        if (values === null) {
            this.barsContainer.selectAll(`rect.${FG_CLASSNAME}`)
                .style('fill', (_d, i) => {
                const d = this._data[i];
                return d.color || this._color;
            });
            this.brushArea.call(this.brush.move, null);
            return;
        }
        const yCoord = this.yScale(this.yScale.domain()[0]);
        // Convert back to space coordinates
        const spaceValues = values
            .map(this.xScale);
        this.brushArea.call(this.brush.move, spaceValues);
        this.customHandles
            .style('opacity', 1)
            .attr('transform', (_d, i) => {
            return `translate(${(spaceValues[i] - (CUSTOM_HANDLE_WIDTH / 2) - 1)},${yCoord - CUSTOM_HANDLE_HEIGHT / 2})`;
        });
        this.brushArea.selectAll('.bottomline')
            .style('opacity', 1)
            .attr('stroke-width', 2)
            .attr('x1', spaceValues[0])
            .attr('x2', spaceValues[1]);
        this.barsContainer.selectAll(`rect.${FG_CLASSNAME}`)
            .style('fill', (_d, i) => {
            const d = this._data[i];
            // This should not be possible, but in some weird cases this happens on an intermediate step
            if (!d) {
                return;
            }
            if (i < values[0] || i >= values[1]) {
                return this._barBackgroundColor;
            }
            return d.color || this._color;
        });
    }
    _dataForDomain() {
        const maxData = Math.max.apply(window, this._data.map((data) => data.value));
        const maxBackground = Math.max.apply(window, this._backgroundData.map((data) => data.value));
        if (maxData > maxBackground) {
            return this._data;
        }
        return this._backgroundData;
    }
    _generateYAxis() {
        const yDomain = this.range !== null
            ? this.range
            : dataService.getYDomain(this._dataForDomain());
        this.yAxis = drawService.generateYScale(this.container, yDomain, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING, this.yAxisOptions);
        this.yScale = this.yAxis.scale();
    }
    _renderXAxis() {
        const xDomain = dataService.getXDomain(this._data);
        const xAxis = drawService.renderXAxis(this.container, xDomain, this._data.length, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING, this.axisFormatter, this.xAxisOptions);
        this.xScale = xAxis.scale();
    }
    _showTooltip(barBoundingBox) {
        if (!this.tooltipElement) {
            return;
        }
        select(this.tooltipElement)
            .style('display', 'inline')
            .style('left', `${barBoundingBox.left + (barBoundingBox.width / 2)}px`)
            .style('top', `${barBoundingBox.top}px`);
    }
    _hideTooltip() {
        select(this.tooltipElement)
            .style('display', 'none');
    }
    _renderHeader() {
        if (!this.showHeader) {
            return;
        }
        return h("as-widget-header", { header: this.heading, subheader: this.description, "is-loading": this._isLoading(), "is-empty": this._isEmpty(), error: this.error, "no-data-message": this.noDataHeaderMessage });
    }
    _renderTooltip() {
        return (h("span", { ref: (ref) => this.tooltipElement = ref, role: 'tooltip', class: 'as-tooltip as-tooltip--top' }, this._parseTooltip(this.tooltip)));
    }
    _parseTooltip(tooltip) {
        if (tooltip === null) {
            return null;
        }
        if (Array.isArray(tooltip)) {
            return tooltip.map((text) => this._renderTooltipLine(text));
        }
        return this._renderTooltipLine(tooltip);
    }
    _renderTooltipLine(value) {
        return h("div", null, value);
    }
    _renderLabels() {
        return [
            this.yLabel ? h("div", { class: 'y-label' }, this.yLabel) : '',
            this.xLabel ? h("div", { class: 'x-label' }, this.xLabel) : '',
        ];
    }
    /**
     * Converts to a hex color string, allowing CSS variables to be passed.
     *
     * @param color color string, can be a CSS variable declaration: var(varname[, fallback])
     * @param fallbackColor if the variable is malformed, or if the CSS variable is not defined, this will be returned
     */
    _toColor(color, fallbackColor) {
        if (color.startsWith('var(')) {
            const match = color.match(/var\(([^,\)]+)(,.+)?\)/);
            if (match === null) {
                return fallbackColor;
            }
            const variable = match[1];
            const fallback = (match[2] || '').replace(',', '').trim();
            const computed = getComputedStyle(this.el).getPropertyValue(variable).toLowerCase().trim();
            if (computed.length === 0) {
                return fallback.length === 0 ? fallbackColor : fallback;
            }
            return computed;
        }
        return color;
    }
    _isLoading() {
        return (!this._firstDataSupplied || this.isLoading) && !this.error;
    }
    _isEmpty() {
        return this._data && !this._data.length;
    }
    _hasDataToDisplay() {
        return !(this._isLoading() || this._isEmpty() || this.error);
    }
    formatter(data) {
        const tooltip = [];
        if (this.isCategoricalData) {
            tooltip.push(`${data.category}`);
        }
        else {
            tooltip.push(`${this._xFormatter(data.start)} - ${this._xFormatter(data.end)}`);
        }
        tooltip.push(`${readableNumber(data.value).trim()}`);
        return tooltip;
    }
    _xFormatter(value) {
        if (this.axisFormatter) {
            return this.axisFormatter(value);
        }
        else {
            return conditionalFormatter(value);
        }
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "backgroundData": ["_onBackgroundDataChanged"],
        "data": ["_onDataChanged"],
        "color": ["_onColorChanged"],
        "unselectedColor": ["_onSelectedColorChanged"]
    }; }
    static get style() { return ".as-tooltip{--as--tooltip--background-color:var(--as--color--type-01,#2c2c2c);--as--tooltip--color:var(--as--color--text-contrast,#fff);--as--tooltip--support-color:var(--as--color--white,#fff);--as--tooltip--primary--background-color:var(--as--primary--success,#1785fb);--as--tooltip--primary--color:var(--as--tooltip--support-color);--as--tooltip--secondary--background-color:var(--as--secondary--success,#0f2d53);--as--tooltip--secondary--color:var(--as--tooltip--support-color);--as--tooltip--complementary--background-color:var(--as--complementary--success,#47db99);--as--tooltip--complementary--color:var(--as--tooltip--support-color);--as--tooltip--error--background-color:var(--as--color--error,#f3522b);--as--tooltip--error-color:var(--as--tooltip--support-color);--as--tooltip--warning--background-color:var(--as--color--warning,#fdb32b);--as--tooltip--warning--color:var(--as--tooltip--support-color);--as--tooltip--success--background-color:var(--as--color--success,#80b622);--as--tooltip--success--color:var(--as--tooltip--support-color);display:-ms-inline-flexbox;display:inline-flex;position:relative;padding:4px 8px;border-width:0;border-radius:4px;border-color:var(--as--tooltip--background-color);background:var(--as--tooltip--background-color);color:var(--as--tooltip--color);font:var(--as--font--body)}.as-tooltip:after{content:\"\";position:absolute;border-width:5px;border-style:solid;border-radius:2px;border-color:inherit}.as-tooltip--top:after{top:100%;left:50%;-webkit-transform:translateY(-6px) translateX(-5px) rotate(45deg);transform:translateY(-6px) translateX(-5px) rotate(45deg)}.as-tooltip--bot:after,.as-tooltip--bottom:after{bottom:100%;left:50%;-webkit-transform:translateY(6px) translateX(-5px) rotate(45deg);transform:translateY(6px) translateX(-5px) rotate(45deg)}.as-tooltip--right:after{top:50%;left:0;-webkit-transform:translateY(-5px) translateX(-4px) rotate(45deg);transform:translateY(-5px) translateX(-4px) rotate(45deg)}.as-tooltip--left:after{top:50%;right:0;-webkit-transform:translateY(-4px) translateX(4px) rotate(45deg);transform:translateY(-4px) translateX(4px) rotate(45deg)}.as-tooltip--primary{border-color:var(--as--tooltip--primary--background-color);background:var(--as--tooltip--primary--background-color);color:var(--as--tooltip--primary--color)}.as-tooltip--secondary{border-color:var(--as--tooltip--secondary--background-color);background:var(--as--tooltip--secondary--background-color);color:var(--as--tooltip--secondary--color)}.as-tooltip--complementary{border-color:var(--as--tooltip--complementary--background-color);background:var(--as--tooltip--complementary--background-color);color:var(--as--tooltip--complementary--color)}.as-tooltip--error{border-color:var(--as--tooltip--error--background-color);background:var(--as--tooltip--error--background-color);color:var(--as--tooltip--error--color)}.as-tooltip--warning{border-color:var(--as--tooltip--warning--background-color);background:var(--as--tooltip--warning--background-color);color:var(--as--tooltip--warning--color)}.as-tooltip--success{border-color:var(--as--tooltip--success--background-color);background:var(--as--tooltip--success--background-color);color:var(--as--tooltip--success--color)}as-histogram-widget{--as--histogram-widget--background-color:var(--as--color--ui-01,#fff);--as--histogram-widget--figure--stroke-color:var(--as--color--secondary,#0f2d53);--as--histogram-widget--figure--text-color:var(--as--color--type-01,#2c2c2c);--as--histogram-widget--label-color:var(--as--color--type-01,#2c2c2c);--as--histogram-widget--label-font:var(--as--font--caption);display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;width:100%;min-width:228px;height:100%;max-height:100%;overflow:auto;background:var(--as--histogram-widget--background-color)}as-histogram-widget as-widget-header{padding-top:6px}as-histogram-widget .as-histogram-widget__wrapper{display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;min-height:0}as-histogram-widget .as-histogram-widget--categorical .x-axis{opacity:0}as-histogram-widget .figure{-webkit-box-sizing:border-box;box-sizing:border-box;-ms-flex:1;flex:1;width:100%;min-height:0;padding:18px 8px 17px 30px;overflow:visible}as-histogram-widget .figure--has-x-label{margin-bottom:25px}as-histogram-widget .figure--has-y-label{padding-left:55px}as-histogram-widget .figure text{fill:var(--as--histogram-widget--figure--text-color)}as-histogram-widget .figure .brush .selection{stroke:none;fill:none}as-histogram-widget .figure .foreground-bar{cursor:pointer}as-histogram-widget .figure .y-axis{--widget-axis-text-color:var(--as--color--type-01,#2c2c2c);--widget-axis-line-color:var(--as--color--ui-05,#b3b3b3)}as-histogram-widget .figure .y-axis .tick text{width:30px;fill:var(--widget-axis-text-color);white-space:pre}as-histogram-widget .figure .y-axis .tick line{stroke:var(--widget-axis-line-color);opacity:.1}as-histogram-widget .figure .y-axis .tick line.zero{opacity:.5}as-histogram-widget .figure .x-axis .domain,as-histogram-widget .figure .x-axis .tick line,as-histogram-widget .figure .y-axis .domain{display:none}as-histogram-widget .figure .handle--wrapper{opacity:0}as-histogram-widget .figure .handle--custom{stroke-linecap:round;stroke:var(--as--histogram-widget--figure--stroke-color);fill:#fff;cursor:ew-resize;pointer-events:none}as-histogram-widget .figure .grab-line{stroke:#ccc}as-histogram-widget .figure .bottomline{stroke:var(--as--histogram-widget--figure--stroke-color)}as-histogram-widget .as-histogram-widget__wrapper--disabled svg .bar{cursor:inherit}as-histogram-widget .as-histogram-widget__footer{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;margin-top:8px}as-histogram-widget .as-histogram-widget__selection{margin:0}as-histogram-widget .x-label,as-histogram-widget .y-label{color:var(--as--histogram-widget--label-color);font:var(--as--histogram-widget--label-font);text-align:center}as-histogram-widget .x-label{position:absolute;bottom:0;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}as-histogram-widget .y-label{position:absolute;top:50%;left:0;margin-left:4px;-webkit-transform:rotate(-90deg) translate(-50%);transform:rotate(-90deg) translate(-50%);-webkit-transform-origin:0 0;transform-origin:0 0}as-histogram-widget [role=tooltip]{display:none;position:fixed;-webkit-transform:translate(-50%,-120%);transform:translate(-50%,-120%);pointer-events:none}"; }
};

export { HistogramWidget as as_histogram_widget };
