import { h } from "@stencil/core";
import { event as d3event, select } from 'd3-selection';
import 'd3-transition';
import readableNumber from '../../utils/readable-number';
import { DEFAULT_BACKGROUND_BAR_COLOR, DEFAULT_BACKGROUND_BAR_COLOR_HEX, DEFAULT_BAR_COLOR, DEFAULT_BAR_COLOR_HEX } from '../common/constants';
import contentFragment from '../common/content.fragment';
import brushService from './utils/brush.service';
import dataService, { binsScale, isBackgroundCompatible, isCategoricalData, prepareData } from './utils/data.service';
import drawService, { conditionalFormatter } from './utils/draw.service';
import interactionService from './utils/interaction.service';
const CUSTOM_HANDLE_WIDTH = 8;
const CUSTOM_HANDLE_HEIGHT = 20;
// we could use getComputedStyle instead of these
const X_PADDING = 38;
const Y_PADDING = 40;
const LABEL_PADDING = 25;
const FG_CLASSNAME = 'foreground-bar';
const BG_CLASSNAME = 'background-bar';
/**
 * Histogram Widget
 *
 * @export
 * @class HistogramWidget
 */
export class HistogramWidget {
    constructor() {
        /**
         * Toggles displaying title and description
         *
         * @type {boolean}
         * @memberof HistogramWidget
         */
        this.showHeader = true;
        /**
         * Disables selection brushes and events for the widget
         *
         * @type {boolean}
         * @memberof HistogramWidget
         */
        this.disableInteractivity = false;
        /**
         * Histogram data to be displayed
         *
         * @type {HistogramData[]}
         * @memberof HistogramWidget
         */
        this.data = [];
        /**
         * Data that will be merged into buckets with value === 0
         *
         * @type {HistogramData[]}
         * @memberof HistogramWidget
         */
        this.backgroundData = null;
        /**
         * Override color for the histogram bars
         *
         * @type {string}
         * @memberof HistogramWidget
         */
        this.color = DEFAULT_BAR_COLOR;
        /**
         * Override color for the non selected histogram bars
         *
         * @type {string}
         * @memberof HistogramWidget
         */
        this.unselectedColor = DEFAULT_BACKGROUND_BAR_COLOR;
        /**
         * Function that formats the tooltip. Receives HistogramData and outputs a string
         *
         * @type {(HistogramData) => string}
         * @memberof HistogramWidget
         */
        this.tooltipFormatter = this.formatter;
        /**
         * Use this attribute to put the widget in "loading mode".
         * When loading mode is active, a spinner will be shown and the data will be hidden.
         */
        this.isLoading = false;
        /**
         * Use this widget to put the widget in "error mode".
         * When error mode is active. The header will display the given text.
         * And the body will be display the errorDescription instead any data.
         */
        this.error = '';
        /**
         * Extended error description, only shown when error is present
         */
        this.errorDescription = '';
        /**
         * Message shown in header when no data is available
         */
        this.noDataHeaderMessage = 'NO DATA AVAILABLE';
        /**
         * Message shown in body when no data is available
         */
        this.noDataBodyMessage = 'There is no data to display.';
        /**
         * Use this attribute to decide if the widget should be rerendered on window resize.
         * Defaults to true.
         */
        this.responsive = true;
        /**
         * Text rendered inside the clear selection button
         */
        this.clearText = 'Clear selection';
        /**
         * Function to format the range selected text displayed below the histogram
         *
         * @memberof HistogramWidget
         */
        this.selectedFormatter = this._selectionFormatter;
        /**
         * This prop lets you provide the range of the y-axis so it's not automatically calculated with
         * data or backgroundData. It always starts at 0, you can provide the top value.
         *
         * @memberof HistogramWidget
         */
        this.range = null;
        /**
         * This lets you disable the animations for the bars when showing / updating the data
         *
         * @type {boolean}
         * @memberof HistogramWidget
         */
        this.disableAnimation = false;
        /**
         * This prop is a proxy to some d3-axis options for the X Axis
         *
         * @type {AxisOptions}
         * @memberof TimeSeriesWidget
         */
        this.xAxisOptions = {};
        /**
         * This prop is a proxy to some d3-axis options for the Y Axis
         *
         * @type {AxisOptions}
         * @memberof TimeSeriesWidget
         */
        this.yAxisOptions = {};
        this.selection = null;
        this.tooltip = null;
        this._firstDataSupplied = false;
        this._muteSelectionChanged = false;
        this._lastEmittedSelection = null;
        this.selectionEmpty = true;
        this.selectionFooter = '';
        this._resizeRender = this._resizeRender.bind(this);
        this._setTooltip = this._setTooltip.bind(this);
    }
    _onBackgroundDataChanged(newBackgroundData) {
        if (newBackgroundData === null || newBackgroundData.length === 0) {
            this._prepareData(this.data, null);
            return;
        }
        if (isBackgroundCompatible(this.data, newBackgroundData)) {
            this._prepareData(this.data, newBackgroundData);
        }
    }
    _onDataChanged(newData, oldData) {
        this.onNewData(newData, oldData);
        if (!this._firstDataSupplied) {
            this._firstDataSupplied = Boolean(newData && newData.length);
        }
    }
    onNewData(newData, oldData) {
        // Invalidated, indexes might be different data now
        this._lastEmittedSelection = null;
        if (isBackgroundCompatible(newData, this.backgroundData)) {
            this._prepareData(this.data, this.backgroundData, oldData);
        }
        else {
            this._prepareData(this.data, null, oldData);
        }
    }
    _prepareData(data, backgroundData, oldData) {
        this._data = prepareData(data);
        this._backgroundData = backgroundData === null ? this._mockBackgroundData(data) : prepareData(backgroundData);
        const newScale = binsScale(this._data);
        const wasCategoricalData = !!this.isCategoricalData;
        this.isCategoricalData = isCategoricalData(this._data);
        if (wasCategoricalData !== this.isCategoricalData) {
            this.selection = null;
        }
        else {
            this.selection = this._preadjustSelection(oldData, newScale, data.length);
        }
        this.binsScale = newScale;
        this._muteSelectionChanged = true;
        this._dataJustChanged = true;
    }
    _onColorChanged(newColor) {
        const incomingColor = newColor || DEFAULT_BAR_COLOR;
        this._color = this._toColor(incomingColor, DEFAULT_BAR_COLOR_HEX);
    }
    _onSelectedColorChanged(newColor) {
        const incomingColor = newColor || DEFAULT_BACKGROUND_BAR_COLOR;
        this._barBackgroundColor = this._toColor(incomingColor, DEFAULT_BACKGROUND_BAR_COLOR_HEX);
    }
    /**
     * Default formatting function. Makes the value a readable number and
     * converts it into a string. Useful to compose with your own formatting
     * function.
     *
     * @memberof HistogramWidget
     */
    async defaultFormatter(data) {
        return this.formatter(data);
    }
    /**
     * Returns the current selection
     *
     * @returns {number[] | string[]}
     * @memberof HistogramWidget
     */
    async getSelection() {
        const data = this._dataForSelection(this.selection);
        return this._simplifySelection(data);
    }
    /**
     * Programmatically set the selection. It will be adjusted to the buckets
     * present in {@link data}. To clear see {@link clearSelection} or call with null
     *
     * @param {number[] | null} values
     * @param {boolean} emit Set to true to force emitting the selectionChanged event.
     * @memberof HistogramWidget
     */
    async setSelection(values, emit = false) {
        if (values === null) {
            this._setSelection(null);
            this.emitSelection(this.selectionChanged, this.selection);
            return;
        }
        // This is too tricky, we'd have to make sure that categories are contiguous
        if (values.some((value) => typeof value === 'string')) {
            return;
        }
        const bins = values.map(this.binsScale);
        this._setSelection(bins);
        if (emit || !this._muteSelectionChanged) {
            this.emitSelection(this.selectionChanged, this.selection);
        }
    }
    /**
     * Clears the Histogram selection
     *
     * @memberof HistogramWidget
     */
    async clearSelection() {
        this.setSelection(null);
    }
    /**
     * Formats a number using the component's x-axis formatter if present
     *
     * @memberof HistogramWidget
     */
    async xFormatter(value) {
        return this._xFormatter(value);
    }
    componentDidLoad() {
        this._color = this._toColor(this.color, DEFAULT_BAR_COLOR_HEX);
        this._barBackgroundColor = this._toColor(this.unselectedColor, DEFAULT_BACKGROUND_BAR_COLOR_HEX);
        if (!this._hasDataToDisplay()) {
            return;
        }
        this.isCategoricalData = isCategoricalData(this._data);
        requestAnimationFrame(() => {
            this._renderGraph();
        });
    }
    componentDidUpdate() {
        if (!this._dataJustChanged) {
            return;
        }
        this._renderGraph();
        this._dataJustChanged = false;
    }
    componentWillLoad() {
        addEventListener('resize', this._resizeRender);
        this._firstDataSupplied = Boolean(this.data && this.data.length);
        this.selectionFooter = this.selectedFormatter(this.selection);
        this._onBackgroundDataChanged(this.backgroundData);
        this.onNewData(this.data, null);
    }
    componentDidUnload() {
        removeEventListener('resize', this._resizeRender);
    }
    render() {
        if (this._isLoading()) {
            return (h("as-histogram-widget-placeholder", null, this._renderHeader()));
        }
        return [
            this._renderHeader(),
            this._renderSelection(),
            this._renderContent(),
        ];
    }
    _resizeRender() {
        requestAnimationFrame(() => {
            this._renderGraph();
        });
    }
    _renderContent() {
        const histogramClasses = {
            'as-histogram-widget--categorical': this.isCategoricalData,
            'as-histogram-widget__wrapper': true,
            'as-histogram-widget__wrapper--disabled': this.disableInteractivity
        };
        const svgClasses = {
            'figure': true,
            'figure--has-x-label': !!this.xLabel,
            'figure--has-y-label': !!this.yLabel
        };
        return contentFragment(this._isLoading(), this.error, this._isEmpty(), this.heading, this.errorDescription, this.noDataBodyMessage, h("div", { class: histogramClasses },
            h("svg", { class: svgClasses, ref: (ref) => this.container = select(ref) }),
            this._renderLabels(),
            this._renderTooltip()));
    }
    _mockBackgroundData(data) {
        const min = dataService.getLowerBounds(data);
        return data.map((value) => (Object.assign({}, value, { value: Math.max(0, min) })));
    }
    _selectionFormatter(selection) {
        if (selection === null) {
            return 'All selected';
        }
        if (this.isCategoricalData) {
            return `${selection[1] - selection[0]} selected`;
        }
        let formattedSelection;
        const domainSelection = selection.map(this.binsScale.invert);
        if (this.axisFormatter) {
            formattedSelection = domainSelection.map(this.axisFormatter);
        }
        else {
            formattedSelection = domainSelection.map((e) => `${conditionalFormatter(e)}`);
        }
        return `Selected from ${formattedSelection[0]} to ${formattedSelection[1]}`;
    }
    _renderSelection() {
        if (this._isLoading() || this._isEmpty() || this.error || !this.showClear) {
            return '';
        }
        return h("as-widget-selection", { selection: this.selectionFooter, clearText: this.clearText, showClear: !this.selectionEmpty, onClear: () => this.clearSelection() });
    }
    _renderGraph() {
        if (!this.container || !this.container.node()) {
            return;
        }
        const bbox = this.container.node().getBoundingClientRect();
        const firstRender = this.prevWidth === undefined || this.prevHeight === undefined;
        this.prevWidth = this.width;
        this.prevHeight = this.height;
        this.width = bbox.width;
        this.height = bbox.height;
        const resizing = !firstRender && (this.prevWidth !== this.width || this.height !== this.prevHeight);
        if (this.height === 0 || this.width === 0) {
            return;
        }
        this._generateYAxis();
        this._renderXAxis();
        this.barsContainer = drawService.renderPlot(this.container);
        interactionService.addTooltip(this.container, this.barsContainer, this, this._color, this._barBackgroundColor, (value) => this.tooltipFormatter(value), this._setTooltip, FG_CLASSNAME);
        drawService.renderBars(this._backgroundData, this.yScale, this.container, this.barsContainer, this._barBackgroundColor, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING, this.disableAnimation || resizing, BG_CLASSNAME);
        drawService.renderBars(this._data, this.yScale, this.container, this.barsContainer, this._color, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING, this.disableAnimation || resizing, FG_CLASSNAME);
        drawService.renderYAxis(this.container, this.yAxis, X_PADDING);
        if (!this.disableInteractivity) {
            this.brush = brushService.addBrush(this.width, this.height, this._onBrush.bind(this), this._onBrushEnd.bind(this), CUSTOM_HANDLE_WIDTH, CUSTOM_HANDLE_HEIGHT, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING);
            this.brushArea = brushService.addBrushArea(this.brush, this.container);
            this.customHandles = brushService.addCustomHandles(this.brushArea, CUSTOM_HANDLE_WIDTH, CUSTOM_HANDLE_HEIGHT, this.yScale);
        }
        this._updateSelection();
        this.drawParametersChanged.emit({
            binsScale: this.binsScale,
            container: this.container,
            handleWidth: CUSTOM_HANDLE_WIDTH,
            height: this.height,
            padding: [X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING],
            width: this.width,
            xScale: this.xScale
        });
        this._muteSelectionChanged = false;
    }
    _setTooltip(value, barBBox) {
        if (value === null) {
            this._hideTooltip();
            return;
        }
        this.tooltip = value;
        this._showTooltip(barBBox);
    }
    _updateSelection() {
        if (this.selection === null || this.disableInteractivity) {
            return;
        }
        if (this._selectionInData(this.selection)) {
            this._setSelection(this.selection);
        }
        else {
            this.clearSelection();
        }
    }
    _adjustSelection(values) {
        if (values === null) {
            return null;
        }
        return values.map((value) => this._adjustSelectionValue(value));
    }
    _adjustSelectionValue(value) {
        if (value < 0) {
            return 0;
        }
        if (value >= this._data.length) {
            return this._data.length;
        }
        return Math.round(value);
    }
    _hideCustomHandles() {
        this.customHandles.style('opacity', 0);
        this.brushArea.selectAll('.bottomline').style('opacity', 0);
    }
    _onBrush() {
        if (this.disableInteractivity) {
            return;
        }
        const evt = d3event; // I can't cast this properly :(
        if (evt.selection === null) {
            this._hideCustomHandles();
            return;
        }
        // I don't know why this happens
        if (!evt.sourceEvent || evt.sourceEvent.type === 'brush') {
            return;
        }
        // Convert to our data's domain
        const d0 = evt.selection
            .map((selection) => this.xScale.invert(selection));
        this._setSelection(d0);
    }
    _onBrushEnd() {
        if (this.disableInteractivity) {
            return;
        }
        if (!this._muteSelectionChanged) {
            this.emitSelection(this.selectionChanged, this.selection);
        }
    }
    _setSelection(selection) {
        if (this.disableInteractivity) {
            return;
        }
        const adjustedSelection = this._adjustSelection(selection);
        if (adjustedSelection !== null && (adjustedSelection[0] === adjustedSelection[1])) {
            return;
        }
        const sameSelection = this.selection !== null &&
            adjustedSelection !== null &&
            this.selection.every((d, i) => adjustedSelection[i] === d);
        this.selection = adjustedSelection;
        this._updateHandles(adjustedSelection);
        if (!sameSelection) {
            this._hideTooltip();
            this.emitSelection(this.selectionInput, this.selection);
        }
        this.selectionEmpty = this.selection === null;
        this.selectionFooter = this.selectedFormatter(this.selection);
    }
    // Adjust the selection to the new data
    _preadjustSelection(oldData, newScale, nBuckets) {
        if (!(oldData && this.selection)) {
            return this.selection;
        }
        // For categorical data, we map back the previously selected values into indexes, and return [first, last]
        if (this.isCategoricalData) {
            const selectedCats = this._simplifySelection(this._dataForSelection(this.selection, oldData));
            const selection = selectedCats.map((value) => {
                return this._data.findIndex((d) => d.category === value);
            });
            // At least one of the previous values are missing, we clear the selection
            if (selection.some((e) => e === -1)) {
                return null;
            }
            return [selection[0], selection[selection.length - 1] + 1];
        }
        const oldSelection = this._simplifySelection(this._dataForSelection(this.selection, oldData));
        const newSelection = oldSelection.map(newScale).map(Math.round);
        return [Math.max(0, newSelection[0]), Math.min(nBuckets, newSelection[1])];
    }
    _dataForSelection(selection, from) {
        if (selection === null) {
            return null;
        }
        const data = from !== undefined ? from : this.data;
        if (this.isCategoricalData) {
            return data
                .slice(selection[0], selection[1])
                .map((d) => d);
        }
        return [data[selection[0]], data[selection[1] - 1]];
    }
    _simplifySelection(selection) {
        if (selection === null) {
            return null;
        }
        if (this.isCategoricalData) {
            return selection.map((value) => value.category);
        }
        return [selection[0].start, selection[selection.length - 1].end];
    }
    _sameSelection(first, second) {
        if (first === null || second === null) {
            return false;
        }
        return (first[0] === second[0] && first[1] === second[1]);
    }
    emitSelection(emitter, selection) {
        if (this._sameSelection(selection, this._lastEmittedSelection)) {
            return;
        }
        if (selection === null) {
            emitter.emit(null);
            return;
        }
        const payload = this._dataForSelection(selection);
        const evt = {
            payload,
            selection: this._simplifySelection(payload),
            type: this._eventType()
        };
        emitter.emit(evt);
        if (emitter === this.selectionChanged) {
            this._lastEmittedSelection = [selection[0], selection[1]];
        }
    }
    _eventType() {
        return this.isCategoricalData ? 'categorical' : 'continuous';
    }
    _selectionInData(selection) {
        const domainSelection = selection.map(this.binsScale.invert);
        const inData = domainSelection.map((selectionValue) => {
            return this._data.some((value) => selectionValue >= value.start && selectionValue <= value.end);
        });
        // True if any of the selection values is inside the data
        // Using inData.every(e => e) would be more restrictive
        return inData.some((e) => e);
    }
    _updateHandles(values) {
        if (!this.xScale) {
            return;
        }
        if (values === null) {
            this.barsContainer.selectAll(`rect.${FG_CLASSNAME}`)
                .style('fill', (_d, i) => {
                const d = this._data[i];
                return d.color || this._color;
            });
            this.brushArea.call(this.brush.move, null);
            return;
        }
        const yCoord = this.yScale(this.yScale.domain()[0]);
        // Convert back to space coordinates
        const spaceValues = values
            .map(this.xScale);
        this.brushArea.call(this.brush.move, spaceValues);
        this.customHandles
            .style('opacity', 1)
            .attr('transform', (_d, i) => {
            return `translate(${(spaceValues[i] - (CUSTOM_HANDLE_WIDTH / 2) - 1)},${yCoord - CUSTOM_HANDLE_HEIGHT / 2})`;
        });
        this.brushArea.selectAll('.bottomline')
            .style('opacity', 1)
            .attr('stroke-width', 2)
            .attr('x1', spaceValues[0])
            .attr('x2', spaceValues[1]);
        this.barsContainer.selectAll(`rect.${FG_CLASSNAME}`)
            .style('fill', (_d, i) => {
            const d = this._data[i];
            // This should not be possible, but in some weird cases this happens on an intermediate step
            if (!d) {
                return;
            }
            if (i < values[0] || i >= values[1]) {
                return this._barBackgroundColor;
            }
            return d.color || this._color;
        });
    }
    _dataForDomain() {
        const maxData = Math.max.apply(window, this._data.map((data) => data.value));
        const maxBackground = Math.max.apply(window, this._backgroundData.map((data) => data.value));
        if (maxData > maxBackground) {
            return this._data;
        }
        return this._backgroundData;
    }
    _generateYAxis() {
        const yDomain = this.range !== null
            ? this.range
            : dataService.getYDomain(this._dataForDomain());
        this.yAxis = drawService.generateYScale(this.container, yDomain, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING, this.yAxisOptions);
        this.yScale = this.yAxis.scale();
    }
    _renderXAxis() {
        const xDomain = dataService.getXDomain(this._data);
        const xAxis = drawService.renderXAxis(this.container, xDomain, this._data.length, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING, this.axisFormatter, this.xAxisOptions);
        this.xScale = xAxis.scale();
    }
    _showTooltip(barBoundingBox) {
        if (!this.tooltipElement) {
            return;
        }
        select(this.tooltipElement)
            .style('display', 'inline')
            .style('left', `${barBoundingBox.left + (barBoundingBox.width / 2)}px`)
            .style('top', `${barBoundingBox.top}px`);
    }
    _hideTooltip() {
        select(this.tooltipElement)
            .style('display', 'none');
    }
    _renderHeader() {
        if (!this.showHeader) {
            return;
        }
        return h("as-widget-header", { header: this.heading, subheader: this.description, "is-loading": this._isLoading(), "is-empty": this._isEmpty(), error: this.error, "no-data-message": this.noDataHeaderMessage });
    }
    _renderTooltip() {
        return (h("span", { ref: (ref) => this.tooltipElement = ref, role: 'tooltip', class: 'as-tooltip as-tooltip--top' }, this._parseTooltip(this.tooltip)));
    }
    _parseTooltip(tooltip) {
        if (tooltip === null) {
            return null;
        }
        if (Array.isArray(tooltip)) {
            return tooltip.map((text) => this._renderTooltipLine(text));
        }
        return this._renderTooltipLine(tooltip);
    }
    _renderTooltipLine(value) {
        return h("div", null, value);
    }
    _renderLabels() {
        return [
            this.yLabel ? h("div", { class: 'y-label' }, this.yLabel) : '',
            this.xLabel ? h("div", { class: 'x-label' }, this.xLabel) : '',
        ];
    }
    /**
     * Converts to a hex color string, allowing CSS variables to be passed.
     *
     * @param color color string, can be a CSS variable declaration: var(varname[, fallback])
     * @param fallbackColor if the variable is malformed, or if the CSS variable is not defined, this will be returned
     */
    _toColor(color, fallbackColor) {
        if (color.startsWith('var(')) {
            const match = color.match(/var\(([^,\)]+)(,.+)?\)/);
            if (match === null) {
                return fallbackColor;
            }
            const variable = match[1];
            const fallback = (match[2] || '').replace(',', '').trim();
            const computed = getComputedStyle(this.el).getPropertyValue(variable).toLowerCase().trim();
            if (computed.length === 0) {
                return fallback.length === 0 ? fallbackColor : fallback;
            }
            return computed;
        }
        return color;
    }
    _isLoading() {
        return (!this._firstDataSupplied || this.isLoading) && !this.error;
    }
    _isEmpty() {
        return this._data && !this._data.length;
    }
    _hasDataToDisplay() {
        return !(this._isLoading() || this._isEmpty() || this.error);
    }
    formatter(data) {
        const tooltip = [];
        if (this.isCategoricalData) {
            tooltip.push(`${data.category}`);
        }
        else {
            tooltip.push(`${this._xFormatter(data.start)} - ${this._xFormatter(data.end)}`);
        }
        tooltip.push(`${readableNumber(data.value).trim()}`);
        return tooltip;
    }
    _xFormatter(value) {
        if (this.axisFormatter) {
            return this.axisFormatter(value);
        }
        else {
            return conditionalFormatter(value);
        }
    }
    static get is() { return "as-histogram-widget"; }
    static get originalStyleUrls() { return {
        "$": ["./as-histogram-widget.scss"]
    }; }
    static get styleUrls() { return {
        "$": ["as-histogram-widget.css"]
    }; }
    static get properties() { return {
        "heading": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{string}",
                        "name": "type"
                    }, {
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "Title of the widget to be displayed"
            },
            "attribute": "heading",
            "reflect": false
        },
        "description": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{string}",
                        "name": "type"
                    }, {
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "Description of the widget to be displayed"
            },
            "attribute": "description",
            "reflect": false
        },
        "showHeader": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{boolean}",
                        "name": "type"
                    }, {
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "Toggles displaying title and description"
            },
            "attribute": "show-header",
            "reflect": false,
            "defaultValue": "true"
        },
        "showClear": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{boolean}",
                        "name": "type"
                    }, {
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "Display a clear button that clears the histogram selection."
            },
            "attribute": "show-clear",
            "reflect": false
        },
        "disableInteractivity": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{boolean}",
                        "name": "type"
                    }, {
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "Disables selection brushes and events for the widget"
            },
            "attribute": "disable-interactivity",
            "reflect": false,
            "defaultValue": "false"
        },
        "data": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "HistogramData[]",
                "resolved": "HistogramData[]",
                "references": {
                    "HistogramData": {
                        "location": "import",
                        "path": "./interfaces"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{HistogramData[]}",
                        "name": "type"
                    }, {
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "Histogram data to be displayed"
            },
            "defaultValue": "[]"
        },
        "backgroundData": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "HistogramData[]",
                "resolved": "HistogramData[]",
                "references": {
                    "HistogramData": {
                        "location": "import",
                        "path": "./interfaces"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{HistogramData[]}",
                        "name": "type"
                    }, {
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "Data that will be merged into buckets with value === 0"
            },
            "defaultValue": "null"
        },
        "color": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{string}",
                        "name": "type"
                    }, {
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "Override color for the histogram bars"
            },
            "attribute": "color",
            "reflect": false,
            "defaultValue": "DEFAULT_BAR_COLOR"
        },
        "unselectedColor": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{string}",
                        "name": "type"
                    }, {
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "Override color for the non selected histogram bars"
            },
            "attribute": "unselected-color",
            "reflect": false,
            "defaultValue": "DEFAULT_BACKGROUND_BAR_COLOR"
        },
        "colorRange": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "HistogramColorRange[]",
                "resolved": "HistogramColorRange[]",
                "references": {
                    "HistogramColorRange": {
                        "location": "import",
                        "path": "./interfaces"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{HistogramColorRange[]}",
                        "name": "type"
                    }, {
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "Color range for histogram data"
            }
        },
        "tooltipFormatter": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "(value: HistogramData) => TooltipFormat | Promise<TooltipFormat>",
                "resolved": "(value: HistogramData) => string | string[] | Promise<TooltipFormat>",
                "references": {
                    "HistogramData": {
                        "location": "import",
                        "path": "./interfaces"
                    },
                    "TooltipFormat": {
                        "location": "import",
                        "path": "./interfaces"
                    },
                    "Promise": {
                        "location": "global"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{(HistogramData) => string}",
                        "name": "type"
                    }, {
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "Function that formats the tooltip. Receives HistogramData and outputs a string"
            },
            "defaultValue": "this.formatter"
        },
        "xLabel": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Label the x axis of the histogram with the given string."
            },
            "attribute": "x-label",
            "reflect": false
        },
        "yLabel": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Label the y axis of the histogram with the given string."
            },
            "attribute": "y-label",
            "reflect": false
        },
        "isLoading": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Use this attribute to put the widget in \"loading mode\".\nWhen loading mode is active, a spinner will be shown and the data will be hidden."
            },
            "attribute": "is-loading",
            "reflect": false,
            "defaultValue": "false"
        },
        "error": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Use this widget to put the widget in \"error mode\".\nWhen error mode is active. The header will display the given text.\nAnd the body will be display the errorDescription instead any data."
            },
            "attribute": "error",
            "reflect": false,
            "defaultValue": "''"
        },
        "errorDescription": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Extended error description, only shown when error is present"
            },
            "attribute": "error-description",
            "reflect": false,
            "defaultValue": "''"
        },
        "noDataHeaderMessage": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Message shown in header when no data is available"
            },
            "attribute": "no-data-header-message",
            "reflect": false,
            "defaultValue": "'NO DATA AVAILABLE'"
        },
        "noDataBodyMessage": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Message shown in body when no data is available"
            },
            "attribute": "no-data-body-message",
            "reflect": false,
            "defaultValue": "'There is no data to display.'"
        },
        "responsive": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Use this attribute to decide if the widget should be rerendered on window resize.\nDefaults to true."
            },
            "attribute": "responsive",
            "reflect": false,
            "defaultValue": "true"
        },
        "axisFormatter": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "(value: number | Date) => string",
                "resolved": "(value: number | Date) => string",
                "references": {
                    "Date": {
                        "location": "global"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "Function used to format the x-axis values"
            }
        },
        "clearText": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Text rendered inside the clear selection button"
            },
            "attribute": "clear-text",
            "reflect": false,
            "defaultValue": "'Clear selection'"
        },
        "selectedFormatter": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "(value: number[]) => string",
                "resolved": "(value: number[]) => string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "Function to format the range selected text displayed below the histogram"
            },
            "defaultValue": "this._selectionFormatter"
        },
        "range": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "[number, number]",
                "resolved": "[number, number]",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "This prop lets you provide the range of the y-axis so it's not automatically calculated with\ndata or backgroundData. It always starts at 0, you can provide the top value."
            },
            "defaultValue": "null"
        },
        "disableAnimation": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{boolean}",
                        "name": "type"
                    }, {
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "This lets you disable the animations for the bars when showing / updating the data"
            },
            "attribute": "disable-animation",
            "reflect": false,
            "defaultValue": "false"
        },
        "xAxisOptions": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "AxisOptions",
                "resolved": "AxisOptions",
                "references": {
                    "AxisOptions": {
                        "location": "import",
                        "path": "./interfaces"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{AxisOptions}",
                        "name": "type"
                    }, {
                        "text": "TimeSeriesWidget",
                        "name": "memberof"
                    }],
                "text": "This prop is a proxy to some d3-axis options for the X Axis"
            },
            "defaultValue": "{}"
        },
        "yAxisOptions": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "AxisOptions",
                "resolved": "AxisOptions",
                "references": {
                    "AxisOptions": {
                        "location": "import",
                        "path": "./interfaces"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{AxisOptions}",
                        "name": "type"
                    }, {
                        "text": "TimeSeriesWidget",
                        "name": "memberof"
                    }],
                "text": "This prop is a proxy to some d3-axis options for the Y Axis"
            },
            "defaultValue": "{}"
        }
    }; }
    static get states() { return {
        "tooltip": {},
        "_firstDataSupplied": {},
        "selectionEmpty": {},
        "selectionFooter": {},
        "isCategoricalData": {}
    }; }
    static get events() { return [{
            "method": "selectionChanged",
            "name": "selectionChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [{
                        "text": "{EventEmitter<number[]>}",
                        "name": "type"
                    }, {
                        "text": "HistogramWidget",
                        "name": "memberof"
                    }],
                "text": "Fired when user update or clear the widget selection."
            },
            "complexType": {
                "original": "HistogramSelection",
                "resolved": "HistogramSelection",
                "references": {
                    "HistogramSelection": {
                        "location": "import",
                        "path": "./interfaces"
                    }
                }
            }
        }, {
            "method": "selectionInput",
            "name": "selectionInput",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": ""
            },
            "complexType": {
                "original": "HistogramSelection",
                "resolved": "HistogramSelection",
                "references": {
                    "HistogramSelection": {
                        "location": "import",
                        "path": "./interfaces"
                    }
                }
            }
        }, {
            "method": "drawParametersChanged",
            "name": "drawParametersChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": ""
            },
            "complexType": {
                "original": "RenderOptions",
                "resolved": "RenderOptions",
                "references": {
                    "RenderOptions": {
                        "location": "import",
                        "path": "./types/RenderOptions"
                    }
                }
            }
        }]; }
    static get methods() { return {
        "defaultFormatter": {
            "complexType": {
                "signature": "(data: HistogramData) => Promise<any[]>",
                "parameters": [{
                        "tags": [],
                        "text": ""
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    },
                    "HistogramData": {
                        "location": "import",
                        "path": "./interfaces"
                    }
                },
                "return": "Promise<any[]>"
            },
            "docs": {
                "text": "Default formatting function. Makes the value a readable number and\nconverts it into a string. Useful to compose with your own formatting\nfunction.",
                "tags": [{
                        "name": "memberof",
                        "text": "HistogramWidget"
                    }]
            }
        },
        "getSelection": {
            "complexType": {
                "signature": "() => Promise<(string | number | Date)[]>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    },
                    "Date": {
                        "location": "global"
                    },
                    "Array": {
                        "location": "global"
                    }
                },
                "return": "Promise<(string | number | Date)[]>"
            },
            "docs": {
                "text": "Returns the current selection",
                "tags": [{
                        "name": "returns",
                        "text": undefined
                    }, {
                        "name": "memberof",
                        "text": "HistogramWidget"
                    }]
            }
        },
        "setSelection": {
            "complexType": {
                "signature": "(values: number[], emit?: boolean) => Promise<void>",
                "parameters": [{
                        "tags": [{
                                "text": "values",
                                "name": "param"
                            }],
                        "text": ""
                    }, {
                        "tags": [{
                                "text": "emit Set to true to force emitting the selectionChanged event.",
                                "name": "param"
                            }],
                        "text": "Set to true to force emitting the selectionChanged event."
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Programmatically set the selection. It will be adjusted to the buckets\npresent in {@link data}. To clear see {@link clearSelection} or call with null",
                "tags": [{
                        "name": "param",
                        "text": "values"
                    }, {
                        "name": "param",
                        "text": "emit Set to true to force emitting the selectionChanged event."
                    }, {
                        "name": "memberof",
                        "text": "HistogramWidget"
                    }]
            }
        },
        "clearSelection": {
            "complexType": {
                "signature": "() => Promise<void>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Clears the Histogram selection",
                "tags": [{
                        "name": "memberof",
                        "text": "HistogramWidget"
                    }]
            }
        },
        "xFormatter": {
            "complexType": {
                "signature": "(value: any) => Promise<string>",
                "parameters": [{
                        "tags": [],
                        "text": ""
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<string>"
            },
            "docs": {
                "text": "Formats a number using the component's x-axis formatter if present",
                "tags": [{
                        "name": "memberof",
                        "text": "HistogramWidget"
                    }]
            }
        }
    }; }
    static get elementRef() { return "el"; }
    static get watchers() { return [{
            "propName": "backgroundData",
            "methodName": "_onBackgroundDataChanged"
        }, {
            "propName": "data",
            "methodName": "_onDataChanged"
        }, {
            "propName": "color",
            "methodName": "_onColorChanged"
        }, {
            "propName": "unselectedColor",
            "methodName": "_onSelectedColorChanged"
        }]; }
}
