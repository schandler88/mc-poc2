var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import { r as registerInstance, c as createEvent, h, g as getElement } from './core-a69618da.js';
import { c as contentFragment } from './content.fragment-e220039c.js';
import { r as readableNumber } from './readable-number-b11b551f.js';
import { s as shadeOrBlend } from './styles-b283ec9e.js';
import { e as event, s as select, v as interpolate, w as customEvent, x as touch, y as mouse, l as linear, z as min, A as max, B as format } from './index-3374c455.js';
import { d as dispatch, i as interrupt } from './index-c73eaaa7.js';
import { b as axisBottom, a as axisLeft } from './index-87eae0eb.js';
import { D as DEFAULT_BAR_COLOR, a as DEFAULT_BACKGROUND_BAR_COLOR, d as DEFAULT_BAR_COLOR_HEX, e as DEFAULT_BACKGROUND_BAR_COLOR_HEX } from './constants-2231320f.js';
function noevent() {
    event.preventDefault();
    event.stopImmediatePropagation();
}
function dragDisable(view) {
    var root = view.document.documentElement, selection = select(view).on("dragstart.drag", noevent, true);
    if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent, true);
    }
    else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
    }
}
function yesdrag(view, noclick) {
    var root = view.document.documentElement, selection = select(view).on("dragstart.drag", null);
    if (noclick) {
        selection.on("click.drag", noevent, true);
        setTimeout(function () { selection.on("click.drag", null); }, 0);
    }
    if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
    }
    else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
    }
}
function constant(x) {
    return function () {
        return x;
    };
}
function BrushEvent(target, type, selection) {
    this.target = target;
    this.type = type;
    this.selection = selection;
}
function nopropagation() {
    event.stopImmediatePropagation();
}
function noevent$1() {
    event.preventDefault();
    event.stopImmediatePropagation();
}
var MODE_DRAG = { name: "drag" }, MODE_SPACE = { name: "space" }, MODE_HANDLE = { name: "handle" }, MODE_CENTER = { name: "center" };
function number1(e) {
    return [+e[0], +e[1]];
}
function number2(e) {
    return [number1(e[0]), number1(e[1])];
}
function toucher(identifier) {
    return function (target) {
        return touch(target, event.touches, identifier);
    };
}
var X = {
    name: "x",
    handles: ["w", "e"].map(type),
    input: function (x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
    output: function (xy) { return xy && [xy[0][0], xy[1][0]]; }
};
var Y = {
    name: "y",
    handles: ["n", "s"].map(type),
    input: function (y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
    output: function (xy) { return xy && [xy[0][1], xy[1][1]]; }
};
var cursors = {
    overlay: "crosshair",
    selection: "move",
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
};
var flipX = {
    e: "w",
    w: "e",
    nw: "ne",
    ne: "nw",
    se: "sw",
    sw: "se"
};
var flipY = {
    n: "s",
    s: "n",
    nw: "sw",
    ne: "se",
    se: "ne",
    sw: "nw"
};
var signsX = {
    overlay: +1,
    selection: +1,
    n: null,
    e: +1,
    s: null,
    w: -1,
    nw: -1,
    ne: +1,
    se: +1,
    sw: -1
};
var signsY = {
    overlay: +1,
    selection: +1,
    n: -1,
    e: null,
    s: +1,
    w: null,
    nw: -1,
    ne: -1,
    se: +1,
    sw: +1
};
function type(t) {
    return { type: t };
}
// Ignore right-click, since that should open the context menu.
function defaultFilter() {
    return !event.ctrlKey && !event.button;
}
function defaultExtent() {
    var svg = this.ownerSVGElement || this;
    if (svg.hasAttribute("viewBox")) {
        svg = svg.viewBox.baseVal;
        return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
    }
    return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}
function defaultTouchable() {
    return navigator.maxTouchPoints || ("ontouchstart" in this);
}
// Like d3.local, but with the name “__brush” rather than auto-generated.
function local(node) {
    while (!node.__brush)
        if (!(node = node.parentNode))
            return;
    return node.__brush;
}
function empty(extent) {
    return extent[0][0] === extent[1][0]
        || extent[0][1] === extent[1][1];
}
function brushX() {
    return brush(X);
}
function brush(dim) {
    var extent = defaultExtent, filter = defaultFilter, touchable = defaultTouchable, keys = true, listeners = dispatch("start", "brush", "end"), handleSize = 6, touchending;
    function brush(group) {
        var overlay = group
            .property("__brush", initialize)
            .selectAll(".overlay")
            .data([type("overlay")]);
        overlay.enter().append("rect")
            .attr("class", "overlay")
            .attr("pointer-events", "all")
            .attr("cursor", cursors.overlay)
            .merge(overlay)
            .each(function () {
            var extent = local(this).extent;
            select(this)
                .attr("x", extent[0][0])
                .attr("y", extent[0][1])
                .attr("width", extent[1][0] - extent[0][0])
                .attr("height", extent[1][1] - extent[0][1]);
        });
        group.selectAll(".selection")
            .data([type("selection")])
            .enter().append("rect")
            .attr("class", "selection")
            .attr("cursor", cursors.selection)
            .attr("fill", "#777")
            .attr("fill-opacity", 0.3)
            .attr("stroke", "#fff")
            .attr("shape-rendering", "crispEdges");
        var handle = group.selectAll(".handle")
            .data(dim.handles, function (d) { return d.type; });
        handle.exit().remove();
        handle.enter().append("rect")
            .attr("class", function (d) { return "handle handle--" + d.type; })
            .attr("cursor", function (d) { return cursors[d.type]; });
        group
            .each(redraw)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousedown.brush", started)
            .filter(touchable)
            .on("touchstart.brush", started)
            .on("touchmove.brush", touchmoved)
            .on("touchend.brush touchcancel.brush", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    brush.move = function (group, selection) {
        if (group.selection) {
            group
                .on("start.brush", function () { emitter(this, arguments).beforestart().start(); })
                .on("interrupt.brush end.brush", function () { emitter(this, arguments).end(); })
                .tween("brush", function () {
                var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent), i = interpolate(selection0, selection1);
                function tween(t) {
                    state.selection = t === 1 && selection1 === null ? null : i(t);
                    redraw.call(that);
                    emit.brush();
                }
                return selection0 !== null && selection1 !== null ? tween : tween(1);
            });
        }
        else {
            group
                .each(function () {
                var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent), emit = emitter(that, args).beforestart();
                interrupt(that);
                state.selection = selection1 === null ? null : selection1;
                redraw.call(that);
                emit.start().brush().end();
            });
        }
    };
    brush.clear = function (group) {
        brush.move(group, null);
    };
    function redraw() {
        var group = select(this), selection = local(this).selection;
        if (selection) {
            group.selectAll(".selection")
                .style("display", null)
                .attr("x", selection[0][0])
                .attr("y", selection[0][1])
                .attr("width", selection[1][0] - selection[0][0])
                .attr("height", selection[1][1] - selection[0][1]);
            group.selectAll(".handle")
                .style("display", null)
                .attr("x", function (d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
                .attr("y", function (d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
                .attr("width", function (d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
                .attr("height", function (d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
        }
        else {
            group.selectAll(".selection,.handle")
                .style("display", "none")
                .attr("x", null)
                .attr("y", null)
                .attr("width", null)
                .attr("height", null);
        }
    }
    function emitter(that, args, clean) {
        return (!clean && that.__brush.emitter) || new Emitter(that, args);
    }
    function Emitter(that, args) {
        this.that = that;
        this.args = args;
        this.state = that.__brush;
        this.active = 0;
    }
    Emitter.prototype = {
        beforestart: function () {
            if (++this.active === 1)
                this.state.emitter = this, this.starting = true;
            return this;
        },
        start: function () {
            if (this.starting)
                this.starting = false, this.emit("start");
            else
                this.emit("brush");
            return this;
        },
        brush: function () {
            this.emit("brush");
            return this;
        },
        end: function () {
            if (--this.active === 0)
                delete this.state.emitter, this.emit("end");
            return this;
        },
        emit: function (type) {
            customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
        }
    };
    function started() {
        if (touchending && !event.touches)
            return;
        if (!filter.apply(this, arguments))
            return;
        var that = this, type = event.target.__data__.type, mode = (keys && event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && event.altKey ? MODE_CENTER : MODE_HANDLE), signX = dim === Y ? null : signsX[type], signY = dim === X ? null : signsY[type], state = local(that), extent = state.extent, selection = state.selection, W = extent[0][0], w0, w1, N = extent[0][1], n0, n1, E = extent[1][0], e0, e1, S = extent[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys && event.shiftKey, lockX, lockY, pointer = event.touches ? toucher(event.changedTouches[0].identifier) : mouse, point0 = pointer(that), point = point0, emit = emitter(that, arguments, true).beforestart();
        if (type === "overlay") {
            if (selection)
                moving = true;
            state.selection = selection = [
                [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
                [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
            ];
        }
        else {
            w0 = selection[0][0];
            n0 = selection[0][1];
            e0 = selection[1][0];
            s0 = selection[1][1];
        }
        w1 = w0;
        n1 = n0;
        e1 = e0;
        s1 = s0;
        var group = select(that)
            .attr("pointer-events", "none");
        var overlay = group.selectAll(".overlay")
            .attr("cursor", cursors[type]);
        if (event.touches) {
            emit.moved = moved;
            emit.ended = ended;
        }
        else {
            var view = select(event.view)
                .on("mousemove.brush", moved, true)
                .on("mouseup.brush", ended, true);
            if (keys)
                view
                    .on("keydown.brush", keydowned, true)
                    .on("keyup.brush", keyupped, true);
            dragDisable(event.view);
        }
        nopropagation();
        interrupt(that);
        redraw.call(that);
        emit.start();
        function moved() {
            var point1 = pointer(that);
            if (shifting && !lockX && !lockY) {
                if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1]))
                    lockY = true;
                else
                    lockX = true;
            }
            point = point1;
            moving = true;
            noevent$1();
            move();
        }
        function move() {
            var t;
            dx = point[0] - point0[0];
            dy = point[1] - point0[1];
            switch (mode) {
                case MODE_SPACE:
                case MODE_DRAG: {
                    if (signX)
                        dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
                    if (signY)
                        dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
                    break;
                }
                case MODE_HANDLE: {
                    if (signX < 0)
                        dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
                    else if (signX > 0)
                        dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
                    if (signY < 0)
                        dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
                    else if (signY > 0)
                        dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
                    break;
                }
                case MODE_CENTER: {
                    if (signX)
                        w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
                    if (signY)
                        n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
                    break;
                }
            }
            if (e1 < w1) {
                signX *= -1;
                t = w0, w0 = e0, e0 = t;
                t = w1, w1 = e1, e1 = t;
                if (type in flipX)
                    overlay.attr("cursor", cursors[type = flipX[type]]);
            }
            if (s1 < n1) {
                signY *= -1;
                t = n0, n0 = s0, s0 = t;
                t = n1, n1 = s1, s1 = t;
                if (type in flipY)
                    overlay.attr("cursor", cursors[type = flipY[type]]);
            }
            if (state.selection)
                selection = state.selection; // May be set by brush.move!
            if (lockX)
                w1 = selection[0][0], e1 = selection[1][0];
            if (lockY)
                n1 = selection[0][1], s1 = selection[1][1];
            if (selection[0][0] !== w1
                || selection[0][1] !== n1
                || selection[1][0] !== e1
                || selection[1][1] !== s1) {
                state.selection = [[w1, n1], [e1, s1]];
                redraw.call(that);
                emit.brush();
            }
        }
        function ended() {
            nopropagation();
            if (event.touches) {
                if (event.touches.length)
                    return;
                if (touchending)
                    clearTimeout(touchending);
                touchending = setTimeout(function () { touchending = null; }, 500); // Ghost clicks are delayed!
            }
            else {
                yesdrag(event.view, moving);
                view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
            }
            group.attr("pointer-events", "all");
            overlay.attr("cursor", cursors.overlay);
            if (state.selection)
                selection = state.selection; // May be set by brush.move (on start)!
            if (empty(selection))
                state.selection = null, redraw.call(that);
            emit.end();
        }
        function keydowned() {
            switch (event.keyCode) {
                case 16: { // SHIFT
                    shifting = signX && signY;
                    break;
                }
                case 18: { // ALT
                    if (mode === MODE_HANDLE) {
                        if (signX)
                            e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                        if (signY)
                            s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                        mode = MODE_CENTER;
                        move();
                    }
                    break;
                }
                case 32: { // SPACE; takes priority over ALT
                    if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                        if (signX < 0)
                            e0 = e1 - dx;
                        else if (signX > 0)
                            w0 = w1 - dx;
                        if (signY < 0)
                            s0 = s1 - dy;
                        else if (signY > 0)
                            n0 = n1 - dy;
                        mode = MODE_SPACE;
                        overlay.attr("cursor", cursors.selection);
                        move();
                    }
                    break;
                }
                default: return;
            }
            noevent$1();
        }
        function keyupped() {
            switch (event.keyCode) {
                case 16: { // SHIFT
                    if (shifting) {
                        lockX = lockY = shifting = false;
                        move();
                    }
                    break;
                }
                case 18: { // ALT
                    if (mode === MODE_CENTER) {
                        if (signX < 0)
                            e0 = e1;
                        else if (signX > 0)
                            w0 = w1;
                        if (signY < 0)
                            s0 = s1;
                        else if (signY > 0)
                            n0 = n1;
                        mode = MODE_HANDLE;
                        move();
                    }
                    break;
                }
                case 32: { // SPACE
                    if (mode === MODE_SPACE) {
                        if (event.altKey) {
                            if (signX)
                                e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                            if (signY)
                                s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                            mode = MODE_CENTER;
                        }
                        else {
                            if (signX < 0)
                                e0 = e1;
                            else if (signX > 0)
                                w0 = w1;
                            if (signY < 0)
                                s0 = s1;
                            else if (signY > 0)
                                n0 = n1;
                            mode = MODE_HANDLE;
                        }
                        overlay.attr("cursor", cursors[type]);
                        move();
                    }
                    break;
                }
                default: return;
            }
            noevent$1();
        }
    }
    function touchmoved() {
        emitter(this, arguments).moved();
    }
    function touchended() {
        emitter(this, arguments).ended();
    }
    function initialize() {
        var state = this.__brush || { selection: null };
        state.extent = number2(extent.apply(this, arguments));
        state.dim = dim;
        return state;
    }
    brush.extent = function (_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant(number2(_)), brush) : extent;
    };
    brush.filter = function (_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), brush) : filter;
    };
    brush.handleSize = function (_) {
        return arguments.length ? (handleSize = +_, brush) : handleSize;
    };
    brush.keyModifiers = function (_) {
        return arguments.length ? (keys = !!_, brush) : keys;
    };
    brush.on = function () {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? brush : value;
    };
    return brush;
}
function addBrush(width, height, onBrush, onBrushEnd, CUSTOM_HANDLE_WIDTH, CUSTOM_HANDLE_HEIGHT, X_PADDING, Y_PADDING) {
    return brushX()
        .handleSize(CUSTOM_HANDLE_WIDTH)
        .extent([[0, 0], [width - X_PADDING, height - Y_PADDING + (CUSTOM_HANDLE_HEIGHT / 2)]])
        .on('brush', onBrush)
        .on('end', onBrushEnd);
}
function addBrushArea(brush, container) {
    var brushArea = container.select('g.brush');
    if (brushArea.empty()) {
        brushArea = container.append('g');
        brushArea.attr('class', 'brush');
    }
    brushArea.call(brush);
    return brushArea;
}
function addCustomHandles(brushArea, CUSTOM_HANDLE_WIDTH, CUSTOM_HANDLE_HEIGHT, scale) {
    var bottomLine = brushArea.select('line.bottomline');
    if (bottomLine.empty()) {
        bottomLine = brushArea.append('line')
            .attr('class', 'bottomline')
            .attr('stroke-width', 4)
            .style('opacity', 0)
            .attr('pointer-events', 'none');
    }
    bottomLine
        .attr('y1', scale(0))
        .attr('y2', scale(0));
    var customHandles = brushArea.selectAll('.handle--wrapper');
    var linesMargin = Math.floor((CUSTOM_HANDLE_WIDTH - 2) / 2);
    if (customHandles.empty()) {
        customHandles = customHandles
            .data([{ type: 'w' }, { type: 'e' }])
            .enter()
            .append('g')
            .attr('class', 'handle--wrapper');
        customHandles
            .append('rect')
            .attr('class', 'handle--custom')
            .attr('width', CUSTOM_HANDLE_WIDTH)
            .attr('height', CUSTOM_HANDLE_HEIGHT)
            .attr('rx', 1)
            .attr('ry', 1);
        var handleGrab = customHandles
            .append('g')
            .attr('class', 'handle--grab');
        for (var i = 0; i < 3; i++) {
            handleGrab
                .append('line')
                .attr('transform', "translate(0 " + ((CUSTOM_HANDLE_HEIGHT / 2) - 2) + ")")
                .attr('x1', linesMargin)
                .attr('y1', i * 2)
                .attr('x2', CUSTOM_HANDLE_WIDTH - linesMargin)
                .attr('y2', i * 2)
                .attr('class', 'grab-line');
        }
    }
    return customHandles;
}
var brushService = { addBrush: addBrush, addBrushArea: addBrushArea, addCustomHandles: addCustomHandles };
function binsScale(data) {
    return linear()
        .domain(getXDomain(data))
        .range([0, data.length]);
}
function getXDomain(data) {
    var start = (data.length > 0 ? data[0] : { start: 0 }).start;
    var end = (data.length > 0 ? data[data.length - 1] : { end: 0 }).end;
    return [start, end];
}
function getYDomain(data) {
    return [Math.min(0, getLowerBounds(data)), max(data, function (d) { return d.value; })];
}
function getLowerBounds(data) {
    return min(data, function (d) { return d.value; });
}
function getXScale(domain, width) {
    return linear()
        .domain(domain)
        .range([0, width]);
}
function isCategoricalData(data) {
    // Histogram data is categorical if all elements contain the category property
    return data.every(_hasCategory);
}
function prepareData(data) {
    var hasRange = data.every(_hasRange);
    return data.map(function (d, index) {
        var parsed = Object.assign({}, d);
        if (!hasRange) {
            parsed.start = index;
            parsed.end = index + 1;
        }
        return parsed;
    });
}
function _hasCategory(data) {
    return data.category !== undefined;
}
function _hasRange(data) {
    return data.start !== undefined && data.end !== undefined;
}
/**
 * Checks if an array of data and background data are compatible
 */
function isBackgroundCompatible(data, backgroundData) {
    var isNull = [data, backgroundData].map(function (value) { return value === null; });
    // Both must be null or both must not be null
    if (isNull[0] !== isNull[1]) {
        return false;
    }
    // If both are null, they're automatically compatible
    if (isNull[0] && isNull[1]) {
        return true;
    }
    // They must have the same length
    if (data.length !== backgroundData.length) {
        return true;
    }
    var isCategorical = data.every(_hasCategory);
    var hasRange = data.every(_hasRange);
    for (var index = 0; index < data.length; index++) {
        // If every element has start / end, they must be equal on both arrays for every element
        if (hasRange) {
            if (backgroundData[index].start !== data[index].start ||
                backgroundData[index].end !== data[index].end) {
                return false;
            }
        }
        // If every element has category, they must be equal on both arrays for every element
        if (isCategorical) {
            if (backgroundData[index].category !== data[index].category) {
                return false;
            }
        }
    }
    return true;
}
var dataService = {
    getLowerBounds: getLowerBounds,
    getXDomain: getXDomain,
    getXScale: getXScale,
    getYDomain: getYDomain,
    isBackgroundCompatible: isBackgroundCompatible,
    isCategoricalData: isCategoricalData,
    prepareData: prepareData,
};
var BAR_WIDTH_THRESHOLD = 3;
var formatter = format('.2~s');
var decimalFormatter = format('.2');
function cleanAxes(yAxisSelection) {
    yAxisSelection.select('.domain').remove();
}
function updateAxes(container, xScale, yScale, xAxis, yAxis, xDomain, yDomain) {
    var xAxisSelection = container.select('.xAxis');
    var yAxisSelection = container.select('.yAxis');
    // -- Update scales
    yScale
        .domain(yDomain)
        .nice();
    xScale
        .domain(xDomain);
    // -- Update axes
    xAxisSelection
        .call(xAxis);
    yAxisSelection
        .call(yAxis);
}
function renderPlot(container) {
    if (container.select('.plot').empty()) {
        var barsContainer = container
            .append('g');
        barsContainer
            .attr('class', 'plot');
        return barsContainer;
    }
    return container.select('.plot');
}
function renderBars(data, yScale, container, barsContainer, color, X_PADDING, Y_PADDING, disableAnimation, className) {
    if (disableAnimation === void 0) { disableAnimation = false; }
    if (className === void 0) { className = ''; }
    if (!container || !container.node()) {
        return;
    }
    var barsSeparation = 1;
    var HEIGHT = container.node().getBoundingClientRect().height - Y_PADDING;
    var WIDTH = container.node().getBoundingClientRect().width - X_PADDING;
    data = data === null ? [] : data;
    var barWidth = data.length === 0 ? WIDTH : WIDTH / data.length;
    if (barWidth - barsSeparation < BAR_WIDTH_THRESHOLD) {
        barsSeparation = 0;
    }
    // -- Draw bars
    this.bars = barsContainer
        .selectAll("rect." + className)
        .data(data);
    // -- Exit
    this.bars.exit().remove()
        .transition()
        .duration(200);
    // -- Enter
    var mergeSelection = this.bars
        .enter()
        .append('rect')
        .attr('y', HEIGHT)
        .attr('height', 0)
        .merge(this.bars)
        .attr('class', "bar " + className)
        .attr('x', function (_d, index) { return index * barWidth; })
        .attr('width', function () { return Math.max(0, barWidth - barsSeparation); })
        .style('fill', function (d) { return d.color || color; });
    var minDomain = yScale.domain()[0];
    var yZero = yScale(Math.max(0, minDomain));
    (disableAnimation ? mergeSelection : mergeSelection.transition().delay(_delayFn))
        .attr('height', function (d) {
        return Math.abs(yScale(d.value) - yZero);
    })
        .attr('y', function (d) { return d.value > 0 ? yScale(d.value) : yZero; });
    // -- Update
    (disableAnimation ? this.bars : this.bars.transition().delay(_delayFn))
        .attr('height', function (d) {
        return Math.abs(yScale(d.value) - yZero);
    })
        .attr('y', function (d) { return d.value > 0 ? yScale(d.value) : yZero; });
}
function renderXAxis(container, domain, bins, X_PADDING, Y_PADDING, customFormatter, axisOptions) {
    if (customFormatter === void 0) { customFormatter = conditionalFormatter; }
    if (!container || !container.node()) {
        return;
    }
    var HEIGHT = container.node().getBoundingClientRect().height - Y_PADDING;
    var WIDTH = container.node().getBoundingClientRect().width - X_PADDING;
    // Display first, last and middle point bins
    var tickValues = [0, bins / 2, bins];
    var tickPadding = axisOptions.padding !== undefined ? axisOptions.padding : 13;
    var ticks = axisOptions.ticks !== undefined ? axisOptions.ticks : tickValues.length;
    var xScale = linear()
        .domain([0, bins])
        .range([0, WIDTH]);
    var realScale = linear()
        .domain(domain)
        .range([0, bins]);
    var xAxis;
    if (axisOptions.values || axisOptions.format) {
        var altScale = linear()
            .domain(domain)
            .range([0, WIDTH]);
        xAxis = axisBottom(altScale)
            .tickValues(axisOptions.values || null)
            .tickFormat(axisOptions.format || customFormatter);
    }
    else {
        xAxis = axisBottom(xScale)
            // tickValues has precedence over ticks, must set null if user wants custom tick number
            .tickValues(ticks !== undefined ? null : tickValues)
            .tickFormat(function (value) {
            var realValue = realScale.invert(value);
            return customFormatter(realValue);
        });
    }
    xAxis
        .tickSize(-HEIGHT)
        .tickPadding(tickPadding)
        .ticks(ticks);
    if (container.select('.x-axis').empty()) {
        container
            .append('g')
            .attr('class', 'x-axis')
            .attr('transform', "translate(0, " + HEIGHT + ")")
            .call(xAxis);
    }
    else {
        container
            .select('.x-axis')
            .attr('transform', "translate(0, " + HEIGHT + ")")
            .call(xAxis);
    }
    container.selectAll('.x-axis text')
        .attr('transform', function (_d, i, collection) {
        var node = collection[i];
        var width = node.getBoundingClientRect().width;
        var xOffset = 0;
        if (i === 0) {
            xOffset = width / 2;
        }
        else if (i === collection.length - 1) {
            xOffset = -width / 2;
        }
        return "translate(" + xOffset + ")";
    })
        .attr('opacity', function (_d, i, collection) {
        // We never hide the first or the last text node
        if (i === 0 || i === collection.length - 1) {
            return 1;
        }
        var textWidth = 0;
        var textElements = collection;
        for (var _i = 0, textElements_1 = textElements; _i < textElements_1.length; _i++) {
            var textEl = textElements_1[_i];
            textWidth += textEl.getBoundingClientRect().width;
        }
        // Hide all other text nodes when there's not enough space
        if (WIDTH - textWidth < 0) {
            return 0;
        }
        return 1;
    });
    return xAxis;
}
function renderYAxis(container, yAxis, X_PADDING) {
    if (!container || !container.node()) {
        return;
    }
    if (container.select('.y-axis').empty()) {
        container
            .append('g')
            .attr('class', 'y-axis')
            .call(yAxis);
    }
    else {
        container.select('.y-axis')
            .call(yAxis);
    }
    // 0 line
    container
        .select('.y-axis')
        .append('g')
        .attr('class', 'tick')
        .attr('opacity', '1')
        .attr('transform', "translate(0," + yAxis.scale()(0) + ")")
        .append('line')
        .attr('shape-rendering', 'crisp')
        .attr('stroke', '#000')
        .attr('class', 'zero')
        .attr('x2', container.node().getBoundingClientRect().width - X_PADDING);
}
function generateYScale(container, domain, X_PADDING, Y_PADDING, axisOptions) {
    if (!container || !container.node()) {
        return;
    }
    var HEIGHT = container.node().getBoundingClientRect().height - Y_PADDING;
    var WIDTH = container.node().getBoundingClientRect().width - X_PADDING;
    var ticks = axisOptions.ticks !== undefined ? axisOptions.ticks : 5;
    var tickPadding = axisOptions.padding !== undefined ? axisOptions.padding : 10;
    // -- Y Axis
    var yScale = linear()
        .domain(domain)
        .range([HEIGHT, 0]);
    var yAxis = axisLeft(yScale)
        .tickSize(-WIDTH)
        .ticks(ticks)
        .tickPadding(tickPadding)
        .tickFormat(axisOptions.format || conditionalFormatter)
        .tickValues(axisOptions.values || null);
    return yAxis;
}
function _delayFn(_d, i) {
    return i;
}
function conditionalFormatter(value) {
    if (value > 0 && value < 1) {
        return decimalFormatter(value);
    }
    return formatter(value);
}
var drawService = {
    cleanAxes: cleanAxes,
    conditionalFormatter: conditionalFormatter,
    generateYScale: generateYScale,
    renderBars: renderBars,
    renderPlot: renderPlot,
    renderXAxis: renderXAxis,
    renderYAxis: renderYAxis,
    updateAxes: updateAxes
};
function addTooltip(container, barsContainer, hasSelection, color, unselectedColor, formatter, setTooltip, className) {
    var _this = this;
    container.on('mousemove', function () {
        var evt = event;
        var clientX = evt.clientX, clientY = evt.clientY;
        var anyHovered = false;
        _forEachRect(barsContainer, clientX, clientY, className, function (data, node, bucketIndex, boundingBox) { return __awaiter(_this, void 0, void 0, function () {
            var selected, _color, tooltip;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        selected = _isSelected(hasSelection.selection, bucketIndex);
                        _color = selected ? data.color || color : unselectedColor;
                        _color = shadeOrBlend(-0.16, _color);
                        node.style('fill', _color);
                        return [4 /*yield*/, formatter(data)];
                    case 1:
                        tooltip = _a.sent();
                        setTooltip(tooltip, boundingBox, evt);
                        anyHovered = true;
                        return [2 /*return*/];
                }
            });
        }); }, function (data, node, bucketIndex) {
            var selected = _isSelected(hasSelection.selection, bucketIndex);
            node.style('fill', selected ? data.color || color : unselectedColor);
        });
        if (!anyHovered) {
            setTooltip(null, null);
        }
    })
        .on('click', function () {
        var evt = event;
        var clientX = evt.clientX, clientY = evt.clientY;
        _forEachRect(barsContainer, clientX, clientY, className, function (data) {
            hasSelection.setSelection([data.start, data.end], true);
        });
    })
        .on('mouseleave', function () {
        setTooltip(null, null);
        barsContainer.selectAll("rect." + className)
            .style('fill', function (data, bucketIndex) {
            if (_isSelected(hasSelection.selection, bucketIndex)) {
                return data.color || color;
            }
            return unselectedColor;
        });
    });
}
function _isSelected(range, bucketIndex) {
    if (range === null) {
        return true;
    }
    return bucketIndex >= range[0] && bucketIndex < range[1];
}
/**
 * Cycles through all rects in container, fires a callback for the rect that contains the x / y points,
 * and fires another (optional) callback for the rest of the containers
 *
 * @param {SVGGContainer} container Container that contains rect elements
 * @param {number} x X coordinate to check whether is contained or not
 * @param {number} y Y coordinate to check whether is contained or not
 * @param {RectCallback} insideCallback Callback fired with data of bucket that contains the point
 * @param {RectCallback} [outsideCallback] Callback fired with data of buckets that don't contain the point
 */
function _forEachRect(container, x, y, className, insideCallback, outsideCallback) {
    container.selectAll("rect." + className)
        .each(function (data, i, nodes) {
        var nodeSelection = select(nodes[i]);
        var node = nodes[i];
        var bb = node.getBoundingClientRect();
        var isInsideBB = bb.left <= x &&
            x <= bb.right &&
            bb.top <= y &&
            y <= bb.bottom;
        if (isInsideBB) {
            insideCallback(data, nodeSelection, i, bb);
            return;
        }
        if (outsideCallback) {
            outsideCallback(data, nodeSelection, i, null);
        }
    });
}
var interactionService = { addTooltip: addTooltip };
var CUSTOM_HANDLE_WIDTH = 8;
var CUSTOM_HANDLE_HEIGHT = 20;
// we could use getComputedStyle instead of these
var X_PADDING = 38;
var Y_PADDING = 40;
var LABEL_PADDING = 25;
var FG_CLASSNAME = 'foreground-bar';
var BG_CLASSNAME = 'background-bar';
var HistogramWidget = /** @class */ (function () {
    function class_1(hostRef) {
        registerInstance(this, hostRef);
        /**
         * Toggles displaying title and description
         *
         * @type {boolean}
         * @memberof HistogramWidget
         */
        this.showHeader = true;
        /**
         * Disables selection brushes and events for the widget
         *
         * @type {boolean}
         * @memberof HistogramWidget
         */
        this.disableInteractivity = false;
        /**
         * Histogram data to be displayed
         *
         * @type {HistogramData[]}
         * @memberof HistogramWidget
         */
        this.data = [];
        /**
         * Data that will be merged into buckets with value === 0
         *
         * @type {HistogramData[]}
         * @memberof HistogramWidget
         */
        this.backgroundData = null;
        /**
         * Override color for the histogram bars
         *
         * @type {string}
         * @memberof HistogramWidget
         */
        this.color = DEFAULT_BAR_COLOR;
        /**
         * Override color for the non selected histogram bars
         *
         * @type {string}
         * @memberof HistogramWidget
         */
        this.unselectedColor = DEFAULT_BACKGROUND_BAR_COLOR;
        /**
         * Function that formats the tooltip. Receives HistogramData and outputs a string
         *
         * @type {(HistogramData) => string}
         * @memberof HistogramWidget
         */
        this.tooltipFormatter = this.formatter;
        /**
         * Use this attribute to put the widget in "loading mode".
         * When loading mode is active, a spinner will be shown and the data will be hidden.
         */
        this.isLoading = false;
        /**
         * Use this widget to put the widget in "error mode".
         * When error mode is active. The header will display the given text.
         * And the body will be display the errorDescription instead any data.
         */
        this.error = '';
        /**
         * Extended error description, only shown when error is present
         */
        this.errorDescription = '';
        /**
         * Message shown in header when no data is available
         */
        this.noDataHeaderMessage = 'NO DATA AVAILABLE';
        /**
         * Message shown in body when no data is available
         */
        this.noDataBodyMessage = 'There is no data to display.';
        /**
         * Use this attribute to decide if the widget should be rerendered on window resize.
         * Defaults to true.
         */
        this.responsive = true;
        /**
         * Text rendered inside the clear selection button
         */
        this.clearText = 'Clear selection';
        /**
         * Function to format the range selected text displayed below the histogram
         *
         * @memberof HistogramWidget
         */
        this.selectedFormatter = this._selectionFormatter;
        /**
         * This prop lets you provide the range of the y-axis so it's not automatically calculated with
         * data or backgroundData. It always starts at 0, you can provide the top value.
         *
         * @memberof HistogramWidget
         */
        this.range = null;
        /**
         * This lets you disable the animations for the bars when showing / updating the data
         *
         * @type {boolean}
         * @memberof HistogramWidget
         */
        this.disableAnimation = false;
        /**
         * This prop is a proxy to some d3-axis options for the X Axis
         *
         * @type {AxisOptions}
         * @memberof TimeSeriesWidget
         */
        this.xAxisOptions = {};
        /**
         * This prop is a proxy to some d3-axis options for the Y Axis
         *
         * @type {AxisOptions}
         * @memberof TimeSeriesWidget
         */
        this.yAxisOptions = {};
        this.selection = null;
        this.tooltip = null;
        this._firstDataSupplied = false;
        this._muteSelectionChanged = false;
        this._lastEmittedSelection = null;
        this.selectionEmpty = true;
        this.selectionFooter = '';
        this._resizeRender = this._resizeRender.bind(this);
        this._setTooltip = this._setTooltip.bind(this);
        this.selectionChanged = createEvent(this, "selectionChanged", 7);
        this.selectionInput = createEvent(this, "selectionInput", 7);
        this.drawParametersChanged = createEvent(this, "drawParametersChanged", 7);
    }
    class_1.prototype._onBackgroundDataChanged = function (newBackgroundData) {
        if (newBackgroundData === null || newBackgroundData.length === 0) {
            this._prepareData(this.data, null);
            return;
        }
        if (isBackgroundCompatible(this.data, newBackgroundData)) {
            this._prepareData(this.data, newBackgroundData);
        }
    };
    class_1.prototype._onDataChanged = function (newData, oldData) {
        this.onNewData(newData, oldData);
        if (!this._firstDataSupplied) {
            this._firstDataSupplied = Boolean(newData && newData.length);
        }
    };
    class_1.prototype.onNewData = function (newData, oldData) {
        // Invalidated, indexes might be different data now
        this._lastEmittedSelection = null;
        if (isBackgroundCompatible(newData, this.backgroundData)) {
            this._prepareData(this.data, this.backgroundData, oldData);
        }
        else {
            this._prepareData(this.data, null, oldData);
        }
    };
    class_1.prototype._prepareData = function (data, backgroundData, oldData) {
        this._data = prepareData(data);
        this._backgroundData = backgroundData === null ? this._mockBackgroundData(data) : prepareData(backgroundData);
        var newScale = binsScale(this._data);
        var wasCategoricalData = !!this.isCategoricalData;
        this.isCategoricalData = isCategoricalData(this._data);
        if (wasCategoricalData !== this.isCategoricalData) {
            this.selection = null;
        }
        else {
            this.selection = this._preadjustSelection(oldData, newScale, data.length);
        }
        this.binsScale = newScale;
        this._muteSelectionChanged = true;
        this._dataJustChanged = true;
    };
    class_1.prototype._onColorChanged = function (newColor) {
        var incomingColor = newColor || DEFAULT_BAR_COLOR;
        this._color = this._toColor(incomingColor, DEFAULT_BAR_COLOR_HEX);
    };
    class_1.prototype._onSelectedColorChanged = function (newColor) {
        var incomingColor = newColor || DEFAULT_BACKGROUND_BAR_COLOR;
        this._barBackgroundColor = this._toColor(incomingColor, DEFAULT_BACKGROUND_BAR_COLOR_HEX);
    };
    /**
     * Default formatting function. Makes the value a readable number and
     * converts it into a string. Useful to compose with your own formatting
     * function.
     *
     * @memberof HistogramWidget
     */
    class_1.prototype.defaultFormatter = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.formatter(data)];
            });
        });
    };
    /**
     * Returns the current selection
     *
     * @returns {number[] | string[]}
     * @memberof HistogramWidget
     */
    class_1.prototype.getSelection = function () {
        return __awaiter(this, void 0, void 0, function () {
            var data;
            return __generator(this, function (_a) {
                data = this._dataForSelection(this.selection);
                return [2 /*return*/, this._simplifySelection(data)];
            });
        });
    };
    /**
     * Programmatically set the selection. It will be adjusted to the buckets
     * present in {@link data}. To clear see {@link clearSelection} or call with null
     *
     * @param {number[] | null} values
     * @param {boolean} emit Set to true to force emitting the selectionChanged event.
     * @memberof HistogramWidget
     */
    class_1.prototype.setSelection = function (values, emit) {
        if (emit === void 0) { emit = false; }
        return __awaiter(this, void 0, void 0, function () {
            var bins;
            return __generator(this, function (_a) {
                if (values === null) {
                    this._setSelection(null);
                    this.emitSelection(this.selectionChanged, this.selection);
                    return [2 /*return*/];
                }
                // This is too tricky, we'd have to make sure that categories are contiguous
                if (values.some(function (value) { return typeof value === 'string'; })) {
                    return [2 /*return*/];
                }
                bins = values.map(this.binsScale);
                this._setSelection(bins);
                if (emit || !this._muteSelectionChanged) {
                    this.emitSelection(this.selectionChanged, this.selection);
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Clears the Histogram selection
     *
     * @memberof HistogramWidget
     */
    class_1.prototype.clearSelection = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.setSelection(null);
                return [2 /*return*/];
            });
        });
    };
    /**
     * Formats a number using the component's x-axis formatter if present
     *
     * @memberof HistogramWidget
     */
    class_1.prototype.xFormatter = function (value) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._xFormatter(value)];
            });
        });
    };
    class_1.prototype.componentDidLoad = function () {
        var _this = this;
        this._color = this._toColor(this.color, DEFAULT_BAR_COLOR_HEX);
        this._barBackgroundColor = this._toColor(this.unselectedColor, DEFAULT_BACKGROUND_BAR_COLOR_HEX);
        if (!this._hasDataToDisplay()) {
            return;
        }
        this.isCategoricalData = isCategoricalData(this._data);
        requestAnimationFrame(function () {
            _this._renderGraph();
        });
    };
    class_1.prototype.componentDidUpdate = function () {
        if (!this._dataJustChanged) {
            return;
        }
        this._renderGraph();
        this._dataJustChanged = false;
    };
    class_1.prototype.componentWillLoad = function () {
        addEventListener('resize', this._resizeRender);
        this._firstDataSupplied = Boolean(this.data && this.data.length);
        this.selectionFooter = this.selectedFormatter(this.selection);
        this._onBackgroundDataChanged(this.backgroundData);
        this.onNewData(this.data, null);
    };
    class_1.prototype.componentDidUnload = function () {
        removeEventListener('resize', this._resizeRender);
    };
    class_1.prototype.render = function () {
        if (this._isLoading()) {
            return (h("as-histogram-widget-placeholder", null, this._renderHeader()));
        }
        return [
            this._renderHeader(),
            this._renderSelection(),
            this._renderContent(),
        ];
    };
    class_1.prototype._resizeRender = function () {
        var _this = this;
        requestAnimationFrame(function () {
            _this._renderGraph();
        });
    };
    class_1.prototype._renderContent = function () {
        var _this = this;
        var histogramClasses = {
            'as-histogram-widget--categorical': this.isCategoricalData,
            'as-histogram-widget__wrapper': true,
            'as-histogram-widget__wrapper--disabled': this.disableInteractivity
        };
        var svgClasses = {
            'figure': true,
            'figure--has-x-label': !!this.xLabel,
            'figure--has-y-label': !!this.yLabel
        };
        return contentFragment(this._isLoading(), this.error, this._isEmpty(), this.heading, this.errorDescription, this.noDataBodyMessage, h("div", { class: histogramClasses }, h("svg", { class: svgClasses, ref: function (ref) { return _this.container = select(ref); } }), this._renderLabels(), this._renderTooltip()));
    };
    class_1.prototype._mockBackgroundData = function (data) {
        var min = dataService.getLowerBounds(data);
        return data.map(function (value) { return (Object.assign({}, value, { value: Math.max(0, min) })); });
    };
    class_1.prototype._selectionFormatter = function (selection) {
        if (selection === null) {
            return 'All selected';
        }
        if (this.isCategoricalData) {
            return selection[1] - selection[0] + " selected";
        }
        var formattedSelection;
        var domainSelection = selection.map(this.binsScale.invert);
        if (this.axisFormatter) {
            formattedSelection = domainSelection.map(this.axisFormatter);
        }
        else {
            formattedSelection = domainSelection.map(function (e) { return "" + conditionalFormatter(e); });
        }
        return "Selected from " + formattedSelection[0] + " to " + formattedSelection[1];
    };
    class_1.prototype._renderSelection = function () {
        var _this = this;
        if (this._isLoading() || this._isEmpty() || this.error || !this.showClear) {
            return '';
        }
        return h("as-widget-selection", { selection: this.selectionFooter, clearText: this.clearText, showClear: !this.selectionEmpty, onClear: function () { return _this.clearSelection(); } });
    };
    class_1.prototype._renderGraph = function () {
        var _this = this;
        if (!this.container || !this.container.node()) {
            return;
        }
        var bbox = this.container.node().getBoundingClientRect();
        var firstRender = this.prevWidth === undefined || this.prevHeight === undefined;
        this.prevWidth = this.width;
        this.prevHeight = this.height;
        this.width = bbox.width;
        this.height = bbox.height;
        var resizing = !firstRender && (this.prevWidth !== this.width || this.height !== this.prevHeight);
        if (this.height === 0 || this.width === 0) {
            return;
        }
        this._generateYAxis();
        this._renderXAxis();
        this.barsContainer = drawService.renderPlot(this.container);
        interactionService.addTooltip(this.container, this.barsContainer, this, this._color, this._barBackgroundColor, function (value) { return _this.tooltipFormatter(value); }, this._setTooltip, FG_CLASSNAME);
        drawService.renderBars(this._backgroundData, this.yScale, this.container, this.barsContainer, this._barBackgroundColor, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING, this.disableAnimation || resizing, BG_CLASSNAME);
        drawService.renderBars(this._data, this.yScale, this.container, this.barsContainer, this._color, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING, this.disableAnimation || resizing, FG_CLASSNAME);
        drawService.renderYAxis(this.container, this.yAxis, X_PADDING);
        if (!this.disableInteractivity) {
            this.brush = brushService.addBrush(this.width, this.height, this._onBrush.bind(this), this._onBrushEnd.bind(this), CUSTOM_HANDLE_WIDTH, CUSTOM_HANDLE_HEIGHT, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING);
            this.brushArea = brushService.addBrushArea(this.brush, this.container);
            this.customHandles = brushService.addCustomHandles(this.brushArea, CUSTOM_HANDLE_WIDTH, CUSTOM_HANDLE_HEIGHT, this.yScale);
        }
        this._updateSelection();
        this.drawParametersChanged.emit({
            binsScale: this.binsScale,
            container: this.container,
            handleWidth: CUSTOM_HANDLE_WIDTH,
            height: this.height,
            padding: [X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING],
            width: this.width,
            xScale: this.xScale
        });
        this._muteSelectionChanged = false;
    };
    class_1.prototype._setTooltip = function (value, barBBox) {
        if (value === null) {
            this._hideTooltip();
            return;
        }
        this.tooltip = value;
        this._showTooltip(barBBox);
    };
    class_1.prototype._updateSelection = function () {
        if (this.selection === null || this.disableInteractivity) {
            return;
        }
        if (this._selectionInData(this.selection)) {
            this._setSelection(this.selection);
        }
        else {
            this.clearSelection();
        }
    };
    class_1.prototype._adjustSelection = function (values) {
        var _this = this;
        if (values === null) {
            return null;
        }
        return values.map(function (value) { return _this._adjustSelectionValue(value); });
    };
    class_1.prototype._adjustSelectionValue = function (value) {
        if (value < 0) {
            return 0;
        }
        if (value >= this._data.length) {
            return this._data.length;
        }
        return Math.round(value);
    };
    class_1.prototype._hideCustomHandles = function () {
        this.customHandles.style('opacity', 0);
        this.brushArea.selectAll('.bottomline').style('opacity', 0);
    };
    class_1.prototype._onBrush = function () {
        var _this = this;
        if (this.disableInteractivity) {
            return;
        }
        var evt = event; // I can't cast this properly :(
        if (evt.selection === null) {
            this._hideCustomHandles();
            return;
        }
        // I don't know why this happens
        if (!evt.sourceEvent || evt.sourceEvent.type === 'brush') {
            return;
        }
        // Convert to our data's domain
        var d0 = evt.selection
            .map(function (selection) { return _this.xScale.invert(selection); });
        this._setSelection(d0);
    };
    class_1.prototype._onBrushEnd = function () {
        if (this.disableInteractivity) {
            return;
        }
        if (!this._muteSelectionChanged) {
            this.emitSelection(this.selectionChanged, this.selection);
        }
    };
    class_1.prototype._setSelection = function (selection) {
        if (this.disableInteractivity) {
            return;
        }
        var adjustedSelection = this._adjustSelection(selection);
        if (adjustedSelection !== null && (adjustedSelection[0] === adjustedSelection[1])) {
            return;
        }
        var sameSelection = this.selection !== null &&
            adjustedSelection !== null &&
            this.selection.every(function (d, i) { return adjustedSelection[i] === d; });
        this.selection = adjustedSelection;
        this._updateHandles(adjustedSelection);
        if (!sameSelection) {
            this._hideTooltip();
            this.emitSelection(this.selectionInput, this.selection);
        }
        this.selectionEmpty = this.selection === null;
        this.selectionFooter = this.selectedFormatter(this.selection);
    };
    // Adjust the selection to the new data
    class_1.prototype._preadjustSelection = function (oldData, newScale, nBuckets) {
        var _this = this;
        if (!(oldData && this.selection)) {
            return this.selection;
        }
        // For categorical data, we map back the previously selected values into indexes, and return [first, last]
        if (this.isCategoricalData) {
            var selectedCats = this._simplifySelection(this._dataForSelection(this.selection, oldData));
            var selection = selectedCats.map(function (value) {
                return _this._data.findIndex(function (d) { return d.category === value; });
            });
            // At least one of the previous values are missing, we clear the selection
            if (selection.some(function (e) { return e === -1; })) {
                return null;
            }
            return [selection[0], selection[selection.length - 1] + 1];
        }
        var oldSelection = this._simplifySelection(this._dataForSelection(this.selection, oldData));
        var newSelection = oldSelection.map(newScale).map(Math.round);
        return [Math.max(0, newSelection[0]), Math.min(nBuckets, newSelection[1])];
    };
    class_1.prototype._dataForSelection = function (selection, from) {
        if (selection === null) {
            return null;
        }
        var data = from !== undefined ? from : this.data;
        if (this.isCategoricalData) {
            return data
                .slice(selection[0], selection[1])
                .map(function (d) { return d; });
        }
        return [data[selection[0]], data[selection[1] - 1]];
    };
    class_1.prototype._simplifySelection = function (selection) {
        if (selection === null) {
            return null;
        }
        if (this.isCategoricalData) {
            return selection.map(function (value) { return value.category; });
        }
        return [selection[0].start, selection[selection.length - 1].end];
    };
    class_1.prototype._sameSelection = function (first, second) {
        if (first === null || second === null) {
            return false;
        }
        return (first[0] === second[0] && first[1] === second[1]);
    };
    class_1.prototype.emitSelection = function (emitter, selection) {
        if (this._sameSelection(selection, this._lastEmittedSelection)) {
            return;
        }
        if (selection === null) {
            emitter.emit(null);
            return;
        }
        var payload = this._dataForSelection(selection);
        var evt = {
            payload: payload,
            selection: this._simplifySelection(payload),
            type: this._eventType()
        };
        emitter.emit(evt);
        if (emitter === this.selectionChanged) {
            this._lastEmittedSelection = [selection[0], selection[1]];
        }
    };
    class_1.prototype._eventType = function () {
        return this.isCategoricalData ? 'categorical' : 'continuous';
    };
    class_1.prototype._selectionInData = function (selection) {
        var _this = this;
        var domainSelection = selection.map(this.binsScale.invert);
        var inData = domainSelection.map(function (selectionValue) {
            return _this._data.some(function (value) { return selectionValue >= value.start && selectionValue <= value.end; });
        });
        // True if any of the selection values is inside the data
        // Using inData.every(e => e) would be more restrictive
        return inData.some(function (e) { return e; });
    };
    class_1.prototype._updateHandles = function (values) {
        var _this = this;
        if (!this.xScale) {
            return;
        }
        if (values === null) {
            this.barsContainer.selectAll("rect." + FG_CLASSNAME)
                .style('fill', function (_d, i) {
                var d = _this._data[i];
                return d.color || _this._color;
            });
            this.brushArea.call(this.brush.move, null);
            return;
        }
        var yCoord = this.yScale(this.yScale.domain()[0]);
        // Convert back to space coordinates
        var spaceValues = values
            .map(this.xScale);
        this.brushArea.call(this.brush.move, spaceValues);
        this.customHandles
            .style('opacity', 1)
            .attr('transform', function (_d, i) {
            return "translate(" + (spaceValues[i] - (CUSTOM_HANDLE_WIDTH / 2) - 1) + "," + (yCoord - CUSTOM_HANDLE_HEIGHT / 2) + ")";
        });
        this.brushArea.selectAll('.bottomline')
            .style('opacity', 1)
            .attr('stroke-width', 2)
            .attr('x1', spaceValues[0])
            .attr('x2', spaceValues[1]);
        this.barsContainer.selectAll("rect." + FG_CLASSNAME)
            .style('fill', function (_d, i) {
            var d = _this._data[i];
            // This should not be possible, but in some weird cases this happens on an intermediate step
            if (!d) {
                return;
            }
            if (i < values[0] || i >= values[1]) {
                return _this._barBackgroundColor;
            }
            return d.color || _this._color;
        });
    };
    class_1.prototype._dataForDomain = function () {
        var maxData = Math.max.apply(window, this._data.map(function (data) { return data.value; }));
        var maxBackground = Math.max.apply(window, this._backgroundData.map(function (data) { return data.value; }));
        if (maxData > maxBackground) {
            return this._data;
        }
        return this._backgroundData;
    };
    class_1.prototype._generateYAxis = function () {
        var yDomain = this.range !== null
            ? this.range
            : dataService.getYDomain(this._dataForDomain());
        this.yAxis = drawService.generateYScale(this.container, yDomain, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING, this.yAxisOptions);
        this.yScale = this.yAxis.scale();
    };
    class_1.prototype._renderXAxis = function () {
        var xDomain = dataService.getXDomain(this._data);
        var xAxis = drawService.renderXAxis(this.container, xDomain, this._data.length, X_PADDING + (this.yLabel ? LABEL_PADDING : 0), Y_PADDING, this.axisFormatter, this.xAxisOptions);
        this.xScale = xAxis.scale();
    };
    class_1.prototype._showTooltip = function (barBoundingBox) {
        if (!this.tooltipElement) {
            return;
        }
        select(this.tooltipElement)
            .style('display', 'inline')
            .style('left', barBoundingBox.left + (barBoundingBox.width / 2) + "px")
            .style('top', barBoundingBox.top + "px");
    };
    class_1.prototype._hideTooltip = function () {
        select(this.tooltipElement)
            .style('display', 'none');
    };
    class_1.prototype._renderHeader = function () {
        if (!this.showHeader) {
            return;
        }
        return h("as-widget-header", { header: this.heading, subheader: this.description, "is-loading": this._isLoading(), "is-empty": this._isEmpty(), error: this.error, "no-data-message": this.noDataHeaderMessage });
    };
    class_1.prototype._renderTooltip = function () {
        var _this = this;
        return (h("span", { ref: function (ref) { return _this.tooltipElement = ref; }, role: 'tooltip', class: 'as-tooltip as-tooltip--top' }, this._parseTooltip(this.tooltip)));
    };
    class_1.prototype._parseTooltip = function (tooltip) {
        var _this = this;
        if (tooltip === null) {
            return null;
        }
        if (Array.isArray(tooltip)) {
            return tooltip.map(function (text) { return _this._renderTooltipLine(text); });
        }
        return this._renderTooltipLine(tooltip);
    };
    class_1.prototype._renderTooltipLine = function (value) {
        return h("div", null, value);
    };
    class_1.prototype._renderLabels = function () {
        return [
            this.yLabel ? h("div", { class: 'y-label' }, this.yLabel) : '',
            this.xLabel ? h("div", { class: 'x-label' }, this.xLabel) : '',
        ];
    };
    /**
     * Converts to a hex color string, allowing CSS variables to be passed.
     *
     * @param color color string, can be a CSS variable declaration: var(varname[, fallback])
     * @param fallbackColor if the variable is malformed, or if the CSS variable is not defined, this will be returned
     */
    class_1.prototype._toColor = function (color, fallbackColor) {
        if (color.startsWith('var(')) {
            var match = color.match(/var\(([^,\)]+)(,.+)?\)/);
            if (match === null) {
                return fallbackColor;
            }
            var variable = match[1];
            var fallback = (match[2] || '').replace(',', '').trim();
            var computed = getComputedStyle(this.el).getPropertyValue(variable).toLowerCase().trim();
            if (computed.length === 0) {
                return fallback.length === 0 ? fallbackColor : fallback;
            }
            return computed;
        }
        return color;
    };
    class_1.prototype._isLoading = function () {
        return (!this._firstDataSupplied || this.isLoading) && !this.error;
    };
    class_1.prototype._isEmpty = function () {
        return this._data && !this._data.length;
    };
    class_1.prototype._hasDataToDisplay = function () {
        return !(this._isLoading() || this._isEmpty() || this.error);
    };
    class_1.prototype.formatter = function (data) {
        var tooltip = [];
        if (this.isCategoricalData) {
            tooltip.push("" + data.category);
        }
        else {
            tooltip.push(this._xFormatter(data.start) + " - " + this._xFormatter(data.end));
        }
        tooltip.push("" + readableNumber(data.value).trim());
        return tooltip;
    };
    class_1.prototype._xFormatter = function (value) {
        if (this.axisFormatter) {
            return this.axisFormatter(value);
        }
        else {
            return conditionalFormatter(value);
        }
    };
    Object.defineProperty(class_1.prototype, "el", {
        get: function () { return getElement(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(class_1, "watchers", {
        get: function () {
            return {
                "backgroundData": ["_onBackgroundDataChanged"],
                "data": ["_onDataChanged"],
                "color": ["_onColorChanged"],
                "unselectedColor": ["_onSelectedColorChanged"]
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(class_1, "style", {
        get: function () { return ".as-tooltip{--as--tooltip--background-color:var(--as--color--type-01,#2c2c2c);--as--tooltip--color:var(--as--color--text-contrast,#fff);--as--tooltip--support-color:var(--as--color--white,#fff);--as--tooltip--primary--background-color:var(--as--primary--success,#1785fb);--as--tooltip--primary--color:var(--as--tooltip--support-color);--as--tooltip--secondary--background-color:var(--as--secondary--success,#0f2d53);--as--tooltip--secondary--color:var(--as--tooltip--support-color);--as--tooltip--complementary--background-color:var(--as--complementary--success,#47db99);--as--tooltip--complementary--color:var(--as--tooltip--support-color);--as--tooltip--error--background-color:var(--as--color--error,#f3522b);--as--tooltip--error-color:var(--as--tooltip--support-color);--as--tooltip--warning--background-color:var(--as--color--warning,#fdb32b);--as--tooltip--warning--color:var(--as--tooltip--support-color);--as--tooltip--success--background-color:var(--as--color--success,#80b622);--as--tooltip--success--color:var(--as--tooltip--support-color);display:-ms-inline-flexbox;display:inline-flex;position:relative;padding:4px 8px;border-width:0;border-radius:4px;border-color:var(--as--tooltip--background-color);background:var(--as--tooltip--background-color);color:var(--as--tooltip--color);font:var(--as--font--body)}.as-tooltip:after{content:\"\";position:absolute;border-width:5px;border-style:solid;border-radius:2px;border-color:inherit}.as-tooltip--top:after{top:100%;left:50%;-webkit-transform:translateY(-6px) translateX(-5px) rotate(45deg);transform:translateY(-6px) translateX(-5px) rotate(45deg)}.as-tooltip--bot:after,.as-tooltip--bottom:after{bottom:100%;left:50%;-webkit-transform:translateY(6px) translateX(-5px) rotate(45deg);transform:translateY(6px) translateX(-5px) rotate(45deg)}.as-tooltip--right:after{top:50%;left:0;-webkit-transform:translateY(-5px) translateX(-4px) rotate(45deg);transform:translateY(-5px) translateX(-4px) rotate(45deg)}.as-tooltip--left:after{top:50%;right:0;-webkit-transform:translateY(-4px) translateX(4px) rotate(45deg);transform:translateY(-4px) translateX(4px) rotate(45deg)}.as-tooltip--primary{border-color:var(--as--tooltip--primary--background-color);background:var(--as--tooltip--primary--background-color);color:var(--as--tooltip--primary--color)}.as-tooltip--secondary{border-color:var(--as--tooltip--secondary--background-color);background:var(--as--tooltip--secondary--background-color);color:var(--as--tooltip--secondary--color)}.as-tooltip--complementary{border-color:var(--as--tooltip--complementary--background-color);background:var(--as--tooltip--complementary--background-color);color:var(--as--tooltip--complementary--color)}.as-tooltip--error{border-color:var(--as--tooltip--error--background-color);background:var(--as--tooltip--error--background-color);color:var(--as--tooltip--error--color)}.as-tooltip--warning{border-color:var(--as--tooltip--warning--background-color);background:var(--as--tooltip--warning--background-color);color:var(--as--tooltip--warning--color)}.as-tooltip--success{border-color:var(--as--tooltip--success--background-color);background:var(--as--tooltip--success--background-color);color:var(--as--tooltip--success--color)}as-histogram-widget{--as--histogram-widget--background-color:var(--as--color--ui-01,#fff);--as--histogram-widget--figure--stroke-color:var(--as--color--secondary,#0f2d53);--as--histogram-widget--figure--text-color:var(--as--color--type-01,#2c2c2c);--as--histogram-widget--label-color:var(--as--color--type-01,#2c2c2c);--as--histogram-widget--label-font:var(--as--font--caption);display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;width:100%;min-width:228px;height:100%;max-height:100%;overflow:auto;background:var(--as--histogram-widget--background-color)}as-histogram-widget as-widget-header{padding-top:6px}as-histogram-widget .as-histogram-widget__wrapper{display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;min-height:0}as-histogram-widget .as-histogram-widget--categorical .x-axis{opacity:0}as-histogram-widget .figure{-webkit-box-sizing:border-box;box-sizing:border-box;-ms-flex:1;flex:1;width:100%;min-height:0;padding:18px 8px 17px 30px;overflow:visible}as-histogram-widget .figure--has-x-label{margin-bottom:25px}as-histogram-widget .figure--has-y-label{padding-left:55px}as-histogram-widget .figure text{fill:var(--as--histogram-widget--figure--text-color)}as-histogram-widget .figure .brush .selection{stroke:none;fill:none}as-histogram-widget .figure .foreground-bar{cursor:pointer}as-histogram-widget .figure .y-axis{--widget-axis-text-color:var(--as--color--type-01,#2c2c2c);--widget-axis-line-color:var(--as--color--ui-05,#b3b3b3)}as-histogram-widget .figure .y-axis .tick text{width:30px;fill:var(--widget-axis-text-color);white-space:pre}as-histogram-widget .figure .y-axis .tick line{stroke:var(--widget-axis-line-color);opacity:.1}as-histogram-widget .figure .y-axis .tick line.zero{opacity:.5}as-histogram-widget .figure .x-axis .domain,as-histogram-widget .figure .x-axis .tick line,as-histogram-widget .figure .y-axis .domain{display:none}as-histogram-widget .figure .handle--wrapper{opacity:0}as-histogram-widget .figure .handle--custom{stroke-linecap:round;stroke:var(--as--histogram-widget--figure--stroke-color);fill:#fff;cursor:ew-resize;pointer-events:none}as-histogram-widget .figure .grab-line{stroke:#ccc}as-histogram-widget .figure .bottomline{stroke:var(--as--histogram-widget--figure--stroke-color)}as-histogram-widget .as-histogram-widget__wrapper--disabled svg .bar{cursor:inherit}as-histogram-widget .as-histogram-widget__footer{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;margin-top:8px}as-histogram-widget .as-histogram-widget__selection{margin:0}as-histogram-widget .x-label,as-histogram-widget .y-label{color:var(--as--histogram-widget--label-color);font:var(--as--histogram-widget--label-font);text-align:center}as-histogram-widget .x-label{position:absolute;bottom:0;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}as-histogram-widget .y-label{position:absolute;top:50%;left:0;margin-left:4px;-webkit-transform:rotate(-90deg) translate(-50%);transform:rotate(-90deg) translate(-50%);-webkit-transform-origin:0 0;transform-origin:0 0}as-histogram-widget [role=tooltip]{display:none;position:fixed;-webkit-transform:translate(-50%,-120%);transform:translate(-50%,-120%);pointer-events:none}"; },
        enumerable: true,
        configurable: true
    });
    return class_1;
}());
export { HistogramWidget as as_histogram_widget };
